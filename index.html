<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHORUS AI: Strategist's Edition V5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* --- Base & Theme Variables --- */
        :root {
            --font-main: 'Inter', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
            --bg-primary: #fdfdfd;
            --bg-secondary: #f3f4f6;
            --bg-modal: white;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-primary: #ccc;
            --border-secondary: #e5e7eb;
            --shadow-primary: 0 4px 6px rgba(0,0,0,0.1);
            --btn-primary-bg: #2563eb;
            --btn-primary-text: white;
            --btn-secondary-bg: #e5e7eb;
            --btn-secondary-text: #374151;
            --link-stroke: #3b82f6;
            --link-arrow: #3b82f6;
            --canvas-grid-primary: rgba(208, 208, 208, 0.5);
            --canvas-bg: #fdfdfd;
            --target-glow-color: rgba(255, 82, 82, 0.75);
        }

        body.theme-dark {
            --bg-primary: #1f2937;
            --bg-secondary: #111827;
            --bg-modal: #374151;
            --text-primary: #d1d5db;
            --text-secondary: #9ca3af;
            --border-primary: #4b5563;
            --border-secondary: #374151;
            --shadow-primary: 0 4px 6px rgba(0,0,0,0.4);
            --btn-primary-bg: #3b82f6;
            --btn-primary-text: white;
            --btn-secondary-bg: #4b5563;
            --btn-secondary-text: #f3f4f6;
            --link-stroke: #60a5fa;
            --link-arrow: #60a5fa;
            --canvas-grid-primary: rgba(75, 85, 99, 0.5);
            --canvas-bg: #1f2937;
            --target-glow-color: rgba(60, 179, 219, 0.75);
        }

        body.theme-blueprint {
            --font-main: 'Roboto Mono', monospace;
            --bg-primary: #0a2140;
            --bg-secondary: #05162c;
            --bg-modal: #0f2d52;
            --text-primary: #a7d8ff;
            --text-secondary: #85b3d6;
            --border-primary: #2563eb;
            --border-secondary: #1e40af;
            --shadow-primary: 0 4px 8px rgba(0, 191, 255, 0.2);
            --btn-primary-bg: #0ea5e9;
            --btn-primary-text: white;
            --btn-secondary-bg: #1e40af;
            --btn-secondary-text: #e0f2fe;
            --link-stroke: #38bdf8;
            --link-arrow: #38bdf8;
            --canvas-grid-primary: rgba(56, 189, 248, 0.2);
            --canvas-bg: #0a2140;
            --target-glow-color: rgba(56, 189, 248, 0.75);
        }

        body.theme-camo {
            --font-main: 'Inter', sans-serif;
            --bg-primary: #eef0eb;
            --bg-secondary: #cad0c3;
            --bg-modal: #f6f7f5;
            --text-primary: #3d4239;
            --text-secondary: #5e635a;
            --border-primary: #a7ad9e;
            --border-secondary: #c1c6b9;
            --shadow-primary: 0 2px 5px rgba(0,0,0,0.15);
            --btn-primary-bg: #6a7f64;
            --btn-primary-text: #ffffff;
            --btn-secondary-bg: #d8ddd3;
            --btn-secondary-text: #3d4239;
            --link-stroke: #5a6356;
            --link-arrow: #5a6356;
            --canvas-grid-primary: rgba(61, 66, 57, 0.15);
            --canvas-bg: #e3e6df;
            --target-glow-color: rgba(106, 127, 100, 0.85);
        }

        body.theme-wargaming {
            --font-main: 'Roboto Mono', monospace;
            --bg-primary: #fdf5e6; /* Old Lace */
            --bg-secondary: #d2b48c; /* Tan */
            --bg-modal: #faebd7; /* AntiqueWhite */
            --text-primary: #5a3a22;
            --text-secondary: #8b4513; /* SaddleBrown */
            --border-primary: #a0522d; /* Sienna */
            --border-secondary: #cd853f; /* Peru */
            --shadow-primary: 0 2px 4px rgba(0,0,0,0.2);
            --btn-primary-bg: #800000; /* Maroon */
            --btn-primary-text: #fff;
            --btn-secondary-bg: #BDB76B; /* DarkKhaki */
            --btn-secondary-text: #000;
            --link-stroke: #800000;
            --link-arrow: #800000;
            --canvas-grid-primary: rgba(139, 69, 19, 0.2);
            --canvas-bg: #f5deb3; /* Wheat */
            --target-glow-color: rgba(128, 0, 0, 0.75);
        }
        
        body.theme-warhammer {
            --font-main: 'Roboto Mono', monospace;
            --bg-primary: #2a2b2e;
            --bg-secondary: #1a1a1c;
            --bg-modal: #3c3d40;
            --text-primary: #d4c6ab;
            --text-secondary: #9a8c78;
            --border-primary: #8b0000;
            --border-secondary: #5a1e1e;
            --shadow-primary: 0 4px 8px rgba(0,0,0,0.5);
            --btn-primary-bg: #8b0000;
            --btn-primary-text: #f0e6d2;
            --btn-secondary-bg: #4a4b4f;
            --btn-secondary-text: #e0d5ba;
            --link-stroke: #c4a56a;
            --link-arrow: #c4a56a;
            --canvas-grid-primary: rgba(196, 165, 106, 0.15);
            --canvas-bg: #212123;
            --target-glow-color: rgba(220, 20, 60, 0.75);
        }
        
        body.theme-space-strategy {
            --font-main: 'Inter', sans-serif;
            --bg-primary: #0f172a;
            --bg-secondary: #020617;
            --bg-modal: #1e293b;
            --text-primary: #cbd5e1;
            --text-secondary: #94a3b8;
            --border-primary: #334155;
            --border-secondary: #475569;
            --shadow-primary: 0 4px 10px rgba(0, 240, 255, 0.2);
            --btn-primary-bg: #00f0ff;
            --btn-primary-text: #020617;
            --btn-secondary-bg: #334155;
            --btn-secondary-text: #e2e8f0;
            --link-stroke: #a252e8;
            --link-arrow: #a252e8;
            --canvas-grid-primary: rgba(0, 240, 255, 0.1);
            --canvas-bg: #0d0f25;
            --target-glow-color: rgba(0, 240, 255, 0.75);
        }

        /* --- Global Styles --- */
        body {
            font-family: var(--font-main);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            overscroll-behavior: none;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }
        #appContainer { width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        .toolbar {
            background-color: var(--bg-modal);
            border-bottom: 1px solid var(--border-secondary);
            box-shadow: var(--shadow-primary);
        }
        #mainContent { position: relative; flex-grow: 1; overflow: hidden; }
        #noteCanvasContainer {
            position: absolute;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--canvas-bg);
            cursor: grab; touch-action: none;
        }
        #noteCanvasContainer:focus { outline: none; }
        #noteCanvasContainer.panning { cursor: grabbing; }
        #transformContainer { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; }
        #noteCanvas {
            width: 16000px; height: 12000px; position: relative;
            background-color: transparent;
        }

        /* --- Center Marker --- */
        #centerMarker {
            position: absolute;
            top: 6000px; /* Center Y of 12000px canvas */
            left: 8000px; /* Center X of 16000px canvas */
            width: 64px;
            height: 64px;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s;
            /* Transform is set by JS to center and apply inverse scale */
        }
        #centerMarker.hidden {
            opacity: 0;
        }
        .target-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border-style: solid;
            border-color: var(--target-glow-color);
        }
        .ring-1 { width: 100%; height: 100%; border-width: 2px; opacity: 0.5; animation: pulse 2s infinite ease-in-out; }
        .ring-2 { width: 60%; height: 60%; border-width: 1px; opacity: 0.8; animation: pulse 2s infinite ease-in-out 0.2s; }
        .target-crosshair { position: absolute; background-color: var(--target-glow-color); }
        .crosshair-h { top: 50%; left: 25%; width: 50%; height: 1px; transform: translateY(-50%); }
        .crosshair-v { left: 50%; top: 25%; height: 50%; width: 1px; transform: translateX(-50%); }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.95); box-shadow: 0 0 0 0 var(--target-glow-color); }
            70% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 0 10px rgba(0,0,0,0); }
            100% { transform: translate(-50%, -50%) scale(0.95); box-shadow: 0 0 0 0 rgba(0,0,0,0); }
        }

        /* --- SVG & Chunks --- */
        #svgCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        .chorus-chunk {
            position: absolute;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            box-shadow: var(--shadow-primary);
            min-width: 200px; min-height: 100px;
            display: flex; flex-direction: column;
            overflow: visible;
            transition: border-color 0.2s, outline 0.2s, opacity 0.3s, transform 0.3s;
            z-index: 1;
            color: var(--text-primary);
        }
        .chorus-chunk.hidden-by-layer { opacity: 0; pointer-events: none; transform: scale(0.9); }
        .chorus-chunk.selected-chunk { border-color: var(--btn-primary-bg); border-width: 2px; }
        .chorus-chunk.linking-source-chunk { outline: 2px solid #16a34a; border-color: #16a34a; }
        
        .chunk-header {
            background-color: var(--bg-modal);
            padding: 6px 10px; font-size: 0.8rem; font-weight: 500;
            cursor: move;
            border-bottom: 1px solid var(--border-primary);
            user-select: none; overflow: hidden;
            display: flex; justify-content: space-between; align-items: center;
            touch-action: none;
        }
        .chunk-header-title { display: flex; flex-direction: column; align-items: flex-start; gap: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chunk-header-main, .chunk-header-sub { display: flex; align-items: center; gap: 0.5rem; }
        .chunk-header-sub { font-size: 0.7rem; color: var(--text-secondary); font-weight: 400; }
        .color-symbol-container { display: flex; align-items: center; gap: 0.25rem; }
        .chunk-header-title .tag { font-weight: 600; color: var(--text-primary) }
        .chunk-header .shape-symbol, .chunk-header .color-symbol { font-weight: normal; }
        .chunk-actions { display: flex; align-items: center; }
        .chunk-action-btn { background: none; border: none; cursor: pointer; padding: 2px; margin-left: 4px; line-height: 1; }
        .chunk-action-btn svg { width: 14px; height: 14px; stroke: var(--text-secondary); stroke-width: 2; }
        .chunk-action-btn:hover svg { stroke: var(--text-primary); }
        .delete-chunk-btn:hover svg { stroke: #dc2626; }
        .ai-chunk-btn:hover svg { stroke: #8b5cf6; }
        .link-chunk-btn.linking-active svg { stroke: #16a34a !important; }
        
        .chunk-content { flex-grow: 1; padding: 12px; font-size: 0.9rem; overflow-y: auto; outline: none; }
        .resize-handle { width: 16px; height: 16px; background-color: var(--border-primary); position: absolute; right: -4px; bottom: -4px; cursor: se-resize; border-top-left-radius: 4px; z-index: 10; touch-action: none; }
        
        .connecting-line { stroke-width: 2; fill: none; transition: opacity 0.3s; stroke: var(--link-stroke); }
        .connecting-line.hidden-by-layer { opacity: 0; }
        .link-type-enables { /* solid - default */ }
        .link-type-informs { stroke-dasharray: 8, 4; }
        .link-type-supports { stroke-dasharray: 2, 6; }
        .link-type-counters { stroke-dasharray: 12, 4, 4, 4; }
        .arrow-head { fill: var(--link-arrow); }
        .link-label { font-family: var(--font-main); font-size: 14px; fill: var(--text-primary); text-anchor: middle; dominant-baseline: middle; pointer-events: none; }
        .link-label-bg { fill: var(--bg-modal); opacity: 0.75; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 10000; }
        .modal-content { background-color: var(--bg-modal); padding: 24px; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); width: 90%; max-width: 500px; color: var(--text-primary); }
        .modal-content.max-w-3xl { max-width: 800px; }
        .form-input, .form-textarea, .form-select, .form-checkbox {
            width: 100%; padding: 8px 12px;
            border: 1px solid var(--border-primary);
            border-radius: 6px; margin-bottom: 12px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        .form-checkbox { width: auto; }
        .form-select { appearance: none; }
        .form-textarea { min-height: 120px; resize: vertical; }
        
        .btn { padding: 8px 12px; border-radius: 6px; font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s, opacity 0.2s; margin-right: 8px; border: none; display: inline-flex; align-items: center; justify-content: center; white-space: nowrap; }
        .btn svg.icon { width: 18px; height: 18px; margin-right: 6px; }
        .btn svg.spinner { width: 18px; height: 18px; margin:auto; }
        .btn.loading { opacity: 0.7; cursor: not-allowed; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--btn-primary-bg); color: var(--btn-primary-text); }
        .btn-primary:hover:not(:disabled):not(.loading) { opacity: 0.85; }
        .btn-secondary { background-color: var(--btn-secondary-bg); color: var(--btn-secondary-text); }
        .btn-secondary:hover:not(:disabled):not(.loading) { opacity: 0.85; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover:not(:disabled):not(.loading) { background-color: #b91c1c; }
        .btn-icon { width: 40px; height: 40px; padding: 0; }

        .modal-scroll-content { max-height: 60vh; overflow-y: auto; padding-right: 1rem; }
        body.linking-mode { cursor: crosshair; }
        body.linking-mode .chorus-chunk:not(.linking-source-chunk):not(.hidden-by-layer):hover { outline: 2px dashed var(--link-stroke); }
        .close-button { color: var(--text-secondary); float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: var(--text-primary); text-decoration: none; cursor: pointer; }
        .help-section { border-bottom: 1px solid var(--border-secondary); padding-bottom: 12px; margin-bottom: 12px; }
        .help-section:last-child { border-bottom: none; }
        
        /* Dropdowns */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { 
            display: none; position: absolute; 
            background-color: var(--bg-modal); 
            min-width: 160px; 
            box-shadow: var(--shadow-primary); 
            z-index: 100; right: 0; 
            border-radius: 6px; padding: 4px; 
            border: 1px solid var(--border-primary);
        }
        .dropdown-content button { display: block; width: 100%; text-align: left; padding: 8px 12px; color: var(--text-primary)}
        .dropdown-content button:hover { background-color: var(--bg-primary); }
        .dropdown-content.show { display: block; }
        #layerControl, #chunkListDropdown { min-width: 220px; }
		        #layerControl, #chunkListDropdown {
             right: auto;
             left: 0;
        }
        #layerControl label { display: block; padding: 8px 12px; cursor: pointer; border-radius: 4px; color: var(--text-primary) }
        #layerControl label:hover { background-color: var(--bg-primary); }
        #layerControl input { margin-right: 10px; }
        #themeSelector button {
             display: block; width: 100%; text-align: left; padding: 8px 12px;
             border: none; background: none; cursor: pointer; border-radius: 4px;
        }
        #themeSelector button:hover { background-color: var(--bg-secondary); }
        
        /* Timeline View */
        #timelineView { display: none; padding: 2rem; overflow-y: auto; height: 100%; }
        .timeline-item { position: relative; padding: 1rem 1rem 1rem 2.5rem; border-left: 3px solid var(--border-primary); margin-bottom: 1rem; transition: margin-left 0.3s ease-in-out; }
        .timeline-item:last-child { border-left: 3px solid transparent; }
        .timeline-dot { position: absolute; left: -9px; top: calc(1rem + 4px); width: 16px; height: 16px; border-radius: 50%; border: 3px solid var(--bg-primary); }
        .timeline-content { background-color: var(--bg-primary); padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .timeline-header { font-weight: 600; font-size: 1.1em; border-bottom: 1px solid var(--border-secondary); padding-bottom: 0.5rem; margin-bottom: 0.5rem; }
        .timeline-meta { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; }

        footer {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div id="appContainer">
        <!-- Toolbar -->
        <div class="toolbar p-3 shadow-md flex flex-wrap items-center justify-center sm:justify-between gap-2 print:hidden">
            <!-- Group 1 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add</button>
                <button id="templatesBtn" class="btn btn-secondary" title="Load a strategic template">Templates</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
            </div>

            <!-- Group 2 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                 <button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
                 <button id="viewToggleBtn" class="btn btn-secondary" title="Toggle Canvas/Timeline View">Timeline</button>
                 <div class="dropdown">
                    <button class="btn btn-secondary">Layers</button>
                    <div id="layerControl" class="dropdown-content"></div>
                </div>
                <div class="dropdown">
                    <button id="chunkListBtn" class="btn btn-secondary" title="Find a chunk">Find</button>
                    <div id="chunkListDropdown" class="dropdown-content max-h-72 overflow-y-auto">
                        <!-- Populated by JS -->
                    </div>
                </div>
                <button id="zoomOutBtn" class="btn btn-secondary" title="Zoom Out (-)">-</button>
                <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (0)">100%</button>
                <button id="zoomInBtn" class="btn btn-secondary" title="Zoom In (+/=)">+</button>
            </div>

            <!-- Group 3 -->
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="summarizeBtn" class="btn btn-secondary" title="Summarize the board with AI"><svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z"></path></svg>Summarize</button>
                <span id="chunkCountDisplay" class="text-sm mx-2">Chunks: 0</span>
                 <div class="dropdown">
                    <button class="btn btn-secondary">Export</button>
                    <div class="dropdown-content">
                        <button id="exportTxtBtn" class="btn btn-secondary w-full">TXT</button>
                        <button id="exportMdBtn" class="btn btn-secondary w-full">Markdown</button>
                        <button id="exportHtmlBtn" class="btn btn-secondary w-full">HTML</button>
                        <button id="exportJsonBtn" class="btn btn-secondary w-full">JSON</button>
                        <button id="exportCsvBtn" class="btn btn-secondary w-full">CSV</button>
                    </div>
                </div>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <button id="settingsBtn" class="btn btn-secondary" title="Settings">Settings</button>
                <button id="helpBtn" class="btn btn-secondary" title="Help (?)">Help</button>
                <button id="donateBtn" class="btn btn-primary btn-icon" title="Support the developer">
                    <i class="fas fa-heart"></i>
                </button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent">
            <div id="noteCanvasContainer" tabindex="-1">
                <div id="transformContainer">
                    <div id="noteCanvas">
                        <svg id="svgCanvas"></svg>
                        <!-- Center marker is positioned on the canvas -->
                        <div id="centerMarker" class="hidden">
                            <div class="target-ring ring-1"></div>
                            <div class="target-ring ring-2"></div>
                            <div class="target-crosshair crosshair-h"></div>
                            <div class="target-crosshair crosshair-v"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="timelineView"></div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-2 text-xs print:hidden">
        &copy; <span id="copyrightYear"></span> Thorsten Becker. CHORUS Strategist's Edition.
        <a href="https://www.linkedin.com/in/thorsten-becker-de/" target="_blank" class="text-blue-600 hover:underline">Connect on LinkedIn</a>.
    </footer>

    <!-- Modals -->
    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Add New Chunk</h2>
            <label for="chunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="chunkTypeSelect" class="form-select"></select>
            <label for="chunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label>
            <select id="chunkShapeSelect" class="form-select"></select>
            <label for="chunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag / Layer:</label>
            <select id="chunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end">
                <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmAddChunkBtn" class="btn btn-primary">Add Chunk</button>
            </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Edit Chunk</h2>
            <input type="hidden" id="editingChunkId">
            <label for="editChunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="editChunkTypeSelect" class="form-select"></select>
            <label for="editChunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label>
            <select id="editChunkShapeSelect" class="form-select"></select>
            <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag / Layer:</label>
            <select id="editChunkColorSelect" class="form-select"></select>
            <div id="editModalActions" class="mt-6 flex justify-between items-center">
                 <button id="manageLinksBtn" class="btn btn-secondary !mr-auto">Relationships</button>
                <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
    <div id="linkEditModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="linkEditTitle">Create Relationship</h2>
            <input type="hidden" id="linkSourceId">
            <input type="hidden" id="linkTargetId">
            <label for="linkTypeSelect" class="block mb-1 font-medium">Relationship Type:</label>
            <select id="linkTypeSelect" class="form-select"></select>
            <label for="linkLabelInput" class="block mb-1 mt-3 font-medium">Note (optional):</label>
            <input type="text" id="linkLabelInput" class="form-input" placeholder="(e.g., This action directly counters the threat)">
            <div class="mt-6 flex justify-end">
                <button id="cancelLinkEditBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmLinkEditBtn" class="btn btn-primary">Create Link</button>
            </div>
        </div>
    </div>
    <div id="unlinkModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Manage Relationships</h2>
            <p class="text-sm mb-4">Edit or remove outgoing relationships from this chunk.</p>
            <div id="unlinkList" class="space-y-2 modal-scroll-content"></div>
            <div class="mt-6 flex justify-end">
                <button id="closeUnlinkModalBtn" class="btn btn-primary">Done</button>
            </div>
        </div>
    </div>
    <div id="templatesModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
            <h2>Load a Template</h2>
            <p class="text-sm mb-4">Loading a template will clear the current canvas.</p>
            <div id="templateList" class="space-y-2 modal-scroll-content"></div>
            <hr class="my-4 border-t border-[var(--border-secondary)]">
            <h3 class="font-semibold text-lg mb-2">Custom Templates</h3>
            <p class="text-sm mb-3">Save the current board as a reusable template, or load one you've previously saved.</p>
            <div class="flex gap-2">
                <button id="saveAsTemplateBtn" class="btn btn-secondary w-full">Save Current as Template</button>
                <button id="loadCustomTemplateBtn" class="btn btn-primary w-full">Load from File</button>
            </div>
        </div>
    </div>
	<div id="settingsModal" class="modal hidden">
		<div class="modal-content max-w-3xl">
			<span id="closeSettingsModalBtn" class="close-button">&times;</span>
			<h2>Settings</h2>
			<div class="modal-scroll-content">
				<div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-4">
					<div>
						<h3 class="font-semibold text-lg mb-2">API Key</h3>
						<label for="geminiApiKeyInput" class="block mb-1 font-medium">Google AI API Key</label>
						<p class="text-xs mb-2">Required for AI features. Your key is saved only in this browser's local storage.</p>
						<input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your API key here">
						<p class="text-xs mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>.</p>
						
						<h3 class="font-semibold text-lg mb-2 mt-6">Canvas Display</h3>
						<label for="gridToggle" class="flex items-center space-x-2 cursor-pointer">
							<input type="checkbox" id="gridToggle" class="form-checkbox">
							<span>Show Grid</span>
						</label>
						<label for="centerMarkerToggle" class="flex items-center space-x-2 cursor-pointer mt-2">
							<input type="checkbox" id="centerMarkerToggle" class="form-checkbox">
							<span>Show Center Marker</span>
						</label>

						<h3 class="font-semibold text-lg mb-2 mt-6">Visual Theme</h3>
						<div id="themeSelector" class="space-y-1">
							<button data-theme="default" class="theme-btn">Default</button>
							<button data-theme="theme-dark" class="theme-btn">Night Ops</button>
							<button data-theme="theme-blueprint" class="theme-btn">Blueprint</button>
							<button data-theme="theme-camo" class="theme-btn">Camouflage</button>
							<button data-theme="theme-wargaming" class="theme-btn">Wargaming</button>
							<button data-theme="theme-warhammer" class="theme-btn">Grim Dark</button>
							<button data-theme="theme-space-strategy" class="theme-btn">Space Strategy</button>
						</div>

					</div>
					<div>
						<h3 class="font-semibold text-lg mb-2">Chunk Type Manager</h3>
						<div id="customTypesContainer" class="space-y-2 max-h-48 overflow-y-auto border p-2 rounded-md bg-gray-50 dark:bg-gray-800"></div>
						<form id="addCustomTypeForm" class="flex gap-2 mt-2">
							<input type="text" id="customTypeTag" placeholder="#new-type" class="form-input mb-0">
							<input type="text" id="customTypeDesc" placeholder="Description" class="form-input mb-0 flex-grow">
							<button type="submit" class="btn btn-primary whitespace-nowrap !m-0">Add Type</button>
						</form>
					</div>
				</div>
			</div>
			 <div class="mt-6 flex justify-end">
				<button id="cancelSettingsBtn" class="btn btn-secondary">Cancel</button>
				<button id="saveSettingsBtn" class="btn btn-primary">Save Settings</button>
			</div>
		</div>
	</div>
    <div id="aiActionModal" class="modal hidden">
        <div class="modal-content">
             <span id="closeAiActionModalBtn" class="close-button">&times;</span>
            <h2 class="flex items-center">AI Assistant</h2>
            <p class="text-sm mb-4">Powered by Gemini. Current chunk content will be used as context.</p>
            <label for="aiPromptTextarea" class="block mb-1 mt-3 font-medium">Your Prompt:</label>
            <textarea id="aiPromptTextarea" class="form-textarea" placeholder="e.g., 'Critique this plan and identify its three main weaknesses.'"></textarea>
            <div class="mt-4 flex flex-wrap justify-between items-center gap-2">
                <button id="aiActionSuggestNextBtn" class="btn btn-secondary">Suggest Next</button>
                <div class="flex-grow"></div>
                <button id="cancelAiActionBtn" class="btn btn-secondary">Cancel</button>
                <button id="aiActionGenerateBtn" class="btn btn-primary">Generate & Replace</button>
            </div>
        </div>
    </div>
    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2>CHORUS Quick Help</h2>
            <div id="help-scroll-content" class="modal-scroll-content">
                <div class="help-section">
                    <h3>What is CHORUS Strategist's Edition?</h3>
                    <p class="mb-2">This is a specialized version of the CHORUS thinking tool, adapted for strategic planning, wargaming, and competitive analysis. It replaces abstract concepts with a practical vocabulary for strategists, allowing you to map out complex operational environments.</p>
                    <p>Use it to visualize plans, analyze threats and opportunities, track resources, and simulate courses of action. The goal is to move beyond linear plans and embrace the dynamic, interconnected nature of strategy.</p>
                </div>
                <div class="help-section">
                    <h3>‚ú® Features</h3>
                    <ul>
                        <li><strong>Themes:</strong> Grim Dark, Space Strategy, and more themes available in Settings.</li>
                        <li><strong>Templates:</strong> Added 4X Strategy template.</li>
                        <li><strong>Custom Templates:</strong> Save your current board as a reusable template and load it later from the 'Templates' modal.</li>
                        <li><strong>Relationship Notes:</strong> Add short text labels to your connection lines to add specific context.</li>
                        <li><strong>Layer Control:</strong> Use the 'Layers' dropdown to show or hide chunks based on their color tag.</li>
                        <li><strong>Timeline View:</strong> Switch to a chronological 'Timeline View' to see your plan unfold sequentially.</li>
                        <li><strong>Custom Chunk Types:</strong> Define your own strategic vocabulary in the Settings modal.</li>
                    </ul>
                </div>
                <div class="help-section"><h3>Keyboard Shortcuts</h3><ul id="shortcutsList"></ul></div>
                <div class="help-section"><h3>Relationship Types</h3><ul id="helpLinkTypes"></ul></div>
                <div class="help-section"><h3>Chunk Types</h3><ul id="helpCoreChunks"></ul></div>
                <div class="help-section"><h3>Shapes (Visual Identifiers)</h3><ul id="helpShapes"></ul></div>
                <div class="help-section"><h3>Color Tags / Layers</h3><ul id="helpColors"></ul></div>
                <div class="help-section">
                    <h3>Usage and Licensing</h3>
                    <p class="mb-2 text-sm">
                        <strong>Free for Personal &amp; Non-Commercial Use:</strong><br>
                        This tool is free for personal use, such as hobbyist wargaming, private study, or non-commercial strategic planning.
                    </p>
                    <p class="mb-2 text-sm">
                        <strong>License Required for Professional &amp; Organizational Use:</strong><br>
                        As a professional tool, a license is required for all other uses. This includes, but is not limited to:
                    </p>
                    <ul class="list-disc list-inside ml-4 text-sm mb-2">
                        <li>Use for business strategy, consulting, or corporate planning.</li>
                        <li>Use in formal military or organizational wargaming and analysis.</li>
                        <li>Use in professional game design and balancing for commercial products.</li>
                        <li>Use for formal academic research or university-level instruction.</li>
                    </ul>
                     <p class="text-sm">
                       Please contact me to discuss licensing options for your team or organization.
                    </p>
                    <p class="mt-2 text-sm">
                        <strong>Contact:</strong> <a href="mailto:hello@thorstenbecker.de" class="text-blue-600 hover:underline">hello@thorstenbecker.de</a>
                    </p>
                </div>
                <div class="help-section">
                    <h3>Copyright</h3>
                    <p>&copy; <span id="copyrightYearHelp"></span> Thorsten Becker &bull; <a href="https://www.thorstenbecker.de" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">thorstenbecker.de</a></p>
                </div>
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3">Message</h2>
            <div id="messageText" class="mb-4 text-sm modal-scroll-content"></div>
            <div id="messageButtons" class="flex justify-end"></div>
        </div>
    </div>

    <!-- NEW: Support/Donate Modal -->
    <div id="supportModal" class="modal hidden">
        <div class="modal-content">
             <span class="close-button" onclick="this.parentElement.parentElement.classList.add('hidden')">&times;</span>
             <h2 class="text-xl font-semibold mb-3">Support CHORUS Strategy</h2>
             <p class="mb-4">Thank you for considering a donation! This project is developed and maintained by an independent creator. Your support helps keep the app free and growing.</p>
             <p>You can support the project here: <a href="https://ko-fi.com/thorstenbecker" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline font-semibold">Ko-fi.com/thorstenbecker</a></p>
             <div class="mt-6 flex justify-end">
                <button class="btn btn-primary" onclick="this.closest('.modal').classList.add('hidden')">Close</button>
            </div>
        </div>
    </div>

    <!-- File inputs for loading data and templates -->
    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">
    <input type="file" id="customTemplateLoadInput" class="hidden" accept=".json,application/json">


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants & Definitions ---
        const DEFAULT_CHUNK_TYPES = {
            core: [ { tag: "#objective", description: "The primary goal or commander's intent" }, { tag: "#asset", description: "A friendly unit, resource, or capability" }, { tag: "#threat", description: "An enemy unit, risk, or obstacle" }, { tag: "#intel", description: "A piece of intelligence or data point" }, { tag: "#action", description: "A planned action or course of action (COA)" }, { tag: "#decision", description: "A key decision point or go/no-go gate" }, { tag: "#assumption", description: "An assumption the plan is based on" } ],
            secondary: [ { tag: "#support", description: "Logistics, supporting effort, or details" }, { tag: "#comms", description: "Communication plan or note" }, { tag: "#contingency", description: "A backup plan or 'what if' scenario" }, { tag: "#feedback", description: "A feedback loop or consequence of an action" }, { tag: "#debrief", description: "Conclusion, lesson learned, after-action report" } ],
        };
        const SHAPES = [ { name: "Circle", symbol: "‚óØ", meaning: "Core, self, central focus" }, { name: "Square", symbol: "‚ñ¢", meaning: "Structure, foundation, argument" }, { name: "Triangle", symbol: "‚ñ≥", meaning: "Change, direction, movement" }, { name: "Diamond", symbol: "‚óá", meaning: "Insight, key moment, crystallization" }, { name: "Target", symbol: "‚óé", meaning: "Objective, Goal, Target" }, { name: "Flag", symbol: "‚öê", meaning: "Key Location, Control Point, Asset" }, { name: "Shield", symbol: "‚õ®", meaning: "Defense, Security, Protection" }, { name: "Bolt", symbol: "‚ö°", meaning: "Action, Attack, High Impact Event" }, { name: "Skull", symbol: "‚ò†", meaning: "Threat, Danger, Critical Risk" }, { name: "Eye", symbol: "üëÅ", meaning: "Intelligence, Observation, Recon" }, { name: "Crossed Swords", symbol: "‚öî", meaning: "Conflict, Battle, Opposition" }, { name: "Question Mark", symbol: "?", meaning: "Unknown, Assumption, Information Gap" }, ];
        const COLORS = [ { name: "Red", symbol: "üî¥", essence: "Threat, Urgency, Stop", tailwindClass: "text-red-500" }, { name: "Blue", symbol: "üîµ", essence: "Friendly, Asset, Go", tailwindClass: "text-blue-500" }, { name: "Green", symbol: "üü¢", essence: "Opportunity, Growth, Go", tailwindClass: "text-green-500" }, { name: "Yellow", symbol: "üü°", essence: "Uncertain, Caution, Neutral", tailwindClass: "text-yellow-400" }, { name: "Purple", symbol: "üü£", essence: "Intel, Command, Key Insight", tailwindClass: "text-purple-500" }, { name: "Grey", symbol: "ü©∂", essence: "Support, Neutral, Background", tailwindClass: "text-gray-500" }, { name: "Black", symbol: "‚ö´", essence: "Finality, Obstacle, Fact", tailwindClass: "text-black" }, { name: "White", symbol: "‚ö™", essence: "Assumption, Blank Slate", tailwindClass: "text-gray-300" } ];
        const LINK_TYPES = [
            { type: "enables", label: "Enables / Causes", style: "solid" },
            { type: "informs", label: "Informs / Exposes", style: "dashed" },
            { type: "supports", label: "Supports / Reinforces", style: "dotted" },
            { type: "counters", label: "Counters / Opposes", style: "complex-dash" }
        ];
        const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
        const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="animate-pulse"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
        const ICON_DELETE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
        const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;

        // --- DOM Elements Cache ---
        const noteCanvasContainer = document.getElementById('noteCanvasContainer'); const mainContent = document.getElementById('mainContent'); const timelineView = document.getElementById('timelineView'); const viewToggleBtn = document.getElementById('viewToggleBtn'); const transformContainer = document.getElementById('transformContainer'); const svgCanvas = document.getElementById('svgCanvas'); const noteCanvas = document.getElementById('noteCanvas'); const addChunkBtn = document.getElementById('addChunkBtn'); const templatesBtn = document.getElementById('templatesBtn'); const templatesModal = document.getElementById('templatesModal'); const templateList = document.getElementById('templateList'); const saveAsTemplateBtn = document.getElementById('saveAsTemplateBtn'); const loadCustomTemplateBtn = document.getElementById('loadCustomTemplateBtn'); const customTemplateLoadInput = document.getElementById('customTemplateLoadInput'); const layerControl = document.getElementById('layerControl'); const clearCanvasBtn = document.getElementById('clearCanvasBtn'); const undoDeleteBtn = document.getElementById('undoDeleteBtn'); const chunkCountDisplay = document.getElementById('chunkCountDisplay'); const zoomInBtn = document.getElementById('zoomInBtn'); const zoomOutBtn = document.getElementById('zoomOutBtn'); const zoomResetBtn = document.getElementById('zoomResetBtn'); const addChunkModal = document.getElementById('addChunkModal'); const chunkTypeSelect = document.getElementById('chunkTypeSelect'); const chunkShapeSelect = document.getElementById('chunkShapeSelect'); const chunkColorSelect = document.getElementById('chunkColorSelect'); const confirmAddChunkBtn = document.getElementById('confirmAddChunkBtn'); const cancelAddChunkBtn = document.getElementById('cancelAddChunkBtn'); const editChunkModal = document.getElementById('editChunkModal'); const editingChunkIdInput = document.getElementById('editingChunkId'); const editChunkTypeSelect = document.getElementById('editChunkTypeSelect'); const editChunkShapeSelect = document.getElementById('editChunkShapeSelect'); const editChunkColorSelect = document.getElementById('editChunkColorSelect'); const confirmEditChunkBtn = document.getElementById('confirmEditChunkBtn'); const cancelEditChunkBtn = document.getElementById('cancelEditChunkBtn'); const summarizeBtn = document.getElementById('summarizeBtn'); const settingsBtn = document.getElementById('settingsBtn'); const settingsModal = document.getElementById('settingsModal'); const geminiApiKeyInput = document.getElementById('geminiApiKeyInput'); const saveSettingsBtn = document.getElementById('saveSettingsBtn'); const cancelSettingsBtn = document.getElementById('cancelSettingsBtn'); const customTypesContainer = document.getElementById('customTypesContainer'); const addCustomTypeForm = document.getElementById('addCustomTypeForm'); const customTypeTagInput = document.getElementById('customTypeTag'); const customTypeDescInput = document.getElementById('customTypeDesc'); const aiActionModal = document.getElementById('aiActionModal'); const aiPromptTextarea = document.getElementById('aiPromptTextarea'); const aiActionGenerateBtn = document.getElementById('aiActionGenerateBtn'); const aiActionSuggestNextBtn = document.getElementById('aiActionSuggestNextBtn'); const cancelAiActionBtn = document.getElementById('cancelAiActionBtn'); const closeAiActionModalBtn = document.getElementById('closeAiActionModalBtn'); const closeSettingsModalBtn = document.getElementById('closeSettingsModalBtn'); const helpBtn = document.getElementById('helpBtn'); const helpModal = document.getElementById('helpModal'); const closeHelpBtn = document.getElementById('closeHelpBtn'); const closeHelpModalSpan = document.getElementById('closeHelpModalSpan'); const saveBtn = document.getElementById('saveBtn'); const loadBtn = document.getElementById('loadBtn'); const fileLoadInput = document.getElementById('fileLoadInput'); const messageModal = document.getElementById('messageModal'); const messageTitle = document.getElementById('messageTitle'); const messageText = document.getElementById('messageText'); const messageButtons = document.getElementById('messageButtons');
        const unlinkModal = document.getElementById('unlinkModal'); const unlinkList = document.getElementById('unlinkList'); const closeUnlinkModalBtn = document.getElementById('closeUnlinkModalBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn'); const exportMdBtn = document.getElementById('exportMdBtn'); const exportHtmlBtn = document.getElementById('exportHtmlBtn'); const exportJsonBtn = document.getElementById('exportJsonBtn'); const exportCsvBtn = document.getElementById('exportCsvBtn');
        const donateBtn = document.getElementById('donateBtn');
        const supportModal = document.getElementById('supportModal');
        const linkEditModal = document.getElementById('linkEditModal'); const linkEditTitle = document.getElementById('linkEditTitle'); const linkTypeSelect = document.getElementById('linkTypeSelect'); const linkLabelInput = document.getElementById('linkLabelInput'); const cancelLinkEditBtn = document.getElementById('cancelLinkEditBtn'); const confirmLinkEditBtn = document.getElementById('confirmLinkEditBtn'); const linkSourceIdInput = document.getElementById('linkSourceId'); const linkTargetIdInput = document.getElementById('linkTargetId');
        const gridToggle = document.getElementById('gridToggle'); const centerMarkerToggle = document.getElementById('centerMarkerToggle'); const centerMarker = document.getElementById('centerMarker');
        const chunkListDropdown = document.getElementById('chunkListDropdown');

        // --- App State ---
        let currentView = 'canvas'; let chunkTypes = {}; let allChunkTypesList = []; let layerVisibility = {}; let chunks = []; let chunksMap = new Map();
        let highestZIndex = 1; let draggedChunk = null; let resizingChunk = null; let interactionStartX = 0; let interactionStartY = 0; let offsetX = 0; let offsetY = 0; let startX = 0; let startY = 0; let startWidth = 0; let startHeight = 0; let selectedChunkId = null; let linkingMode = false; let linkingSourceChunkId = null; let lastDeletedChunk = null; let lastAddedChunkId = null; let geminiApiKey = null; let activeAiChunkId = null;
        let scale = 1; let translateX = 0; let translateY = 0; const MIN_SCALE = 0.1; const MAX_SCALE = 3.0; const ZOOM_SENSITIVITY = 0.001;
        let currentAction = null; let panStartX = 0; let panStartY = 0; let initialPinchDistance = null; let transformUpdateQueued = false;
        let showGrid = true; let showCenterMarker = false;
        
        // --- Added new templates and themes ---
        const STRATEGIC_TEMPLATES = {
            swot: { name: "SWOT Analysis", description: "Analyze Strengths, Weaknesses, Opportunities, and Threats.", chunks: [ { x: 100, y: 100, w: 250, h: 150, type: "#asset", shape: "Shield", color: "Blue", text: "Strengths" }, { x: 400, y: 100, w: 250, h: 150, type: "#threat", shape: "Skull", color: "Red", text: "Weaknesses" }, { x: 100, y: 300, w: 250, h: 150, type: "#asset", shape: "Flag", color: "Green", text: "Opportunities" }, { x: 400, y: 300, w: 250, h: 150, type: "#threat", shape: "Crossed Swords", color: "Red", text: "Threats" } ], links: [] },
            ooda: { name: "OODA Loop", description: "A cycle for decision making: Observe, Orient, Decide, Act.", chunks: [ { id: "o1", x: 350, y: 100, w: 250, h: 120, type: "#intel", shape: "Eye", color: "Purple", text: "Observe" }, { id: "o2", x: 650, y: 300, w: 250, h: 120, type: "#decision", shape: "Triangle", color: "Yellow", text: "Orient" }, { id: "o3", x: 350, y: 500, w: 250, h: 120, type: "#decision", shape: "Diamond", color: "Blue", text: "Decide" }, { id: "o4", x: 50,  y: 300, w: 250, h: 120, type: "#action", shape: "Bolt", color: "Red", text: "Act" } ], links: [{ from: "o1", to: "o2", type: "enables" }, { from: "o2", to: "o3", type: "enables" }, { from: "o3", to: "o4", type: "enables" }, { from: "o4", to: "o1", type: "informs", label: "Feedback" }] },
            coa: { name: "COA Development", description: "Develop and compare multiple Courses of Action.", chunks: [ { id: "c1", x: 500, y: 100, w: 300, h: 120, type: "#objective", shape: "Target", color: "Purple", text: "Primary Objective" }, { id: "c2", x: 200, y: 300, w: 280, h: 150, type: "#action", shape: "Square", color: "Blue", text: "Course of Action 1" }, { id: "c3", x: 200, y: 500, w: 280, h: 150, type: "#support", shape: "Square", color: "Blue", text: "Pros & Cons for COA 1" }, { id: "c4", x: 800, y: 300, w: 280, h: 150, type: "#action", shape: "Square", color: "Yellow", text: "Course of Action 2" }, { id: "c5", x: 800, y: 500, w: 280, h: 150, type: "#support", shape: "Square", color: "Yellow", text: "Pros & Cons for COA 2" } ], links: [{ from: "c1", to: "c2", type: "enables" }, { from: "c2", to: "c3", type: "supports" }, { from: "c1", to: "c4", type: "enables" }, { from: "c4", to: "c5", type: "supports" }] },
            gameDesign: { name: "Game Design Doc", description: "Outline the core pillars of a video game concept.", chunks: [ { id:"gd1", x: 400, y: 100, w: 300, h: 120, type: "#objective", shape: "Diamond", color: "Purple", text: "Core Game Loop" }, { id:"gd2", x: 100, y: 300, w: 250, h: 150, type: "#asset", shape: "Circle", color: "Blue", text: "Player Fantasy" }, { id:"gd3", x: 450, y: 300, w: 250, h: 150, type: "#action", shape: "Bolt", color: "Green", text: "Key Mechanics" }, { id:"gd4", x: 800, y: 300, w: 250, h: 150, type: "#threat", shape: "Skull", color: "Red", text: "Risks & Challenges" }, { id:"gd5", x: 400, y: 500, w: 300, h: 120, type: "#support", shape: "Square", color: "Grey", text: "Art Style & Theme" } ], links: [ {from: "gd1", to: "gd2", type: "enables"}, {from: "gd1", to: "gd3", type: "enables"}, {from: "gd3", to: "gd4", type: "counters"}, {from: "gd1", to: "gd5", type: "supports"} ]},
            tactics: { name: "Tactical Plan", description: "A framework for a tactical engagement (e.g., chess, wargame).", chunks: [ {id:"t1", x: 500, y: 100, w: 250, h: 120, type: "#objective", shape: "Target", color: "Purple", text: "Winning Condition" }, {id:"t2", x: 200, y: 300, w: 250, h: 150, type: "#asset", shape: "Shield", color: "Blue", text: "My Key Strengths" }, {id:"t3", x: 800, y: 300, w: 250, h: 150, type: "#threat", shape: "Crossed Swords", color: "Red", text: "Opponent's Plan" }, {id:"t4", x: 500, y: 500, w: 250, h: 150, type: "#action", shape: "Triangle", color: "Green", text: "My Counter-Moves" } ], links: [ {from: "t1", to: "t2", type: "supports"}, {from: "t3", to: "t4", type: "counters"}, {from: "t2", to: "t4", type: "enables"} ]},
            four_x_strategy: { name: "4X Strategy", description: "A template for eXplore, eXpand, eXploit, eXterminate games.", chunks: [ { id: "x1", x: 100, y: 300, w: 250, h: 150, type: "#action", shape: "Triangle", color: "Blue", text: "eXplore: Scout the unknown" }, { id: "x2", x: 400, y: 300, w: 250, h: 150, type: "#action", shape: "Square", color: "Green", text: "eXpand: Settle new territory" }, { id: "x3", x: 700, y: 300, w: 250, h: 150, type: "#action", shape: "Diamond", color: "Yellow", text: "eXploit: Develop resources" }, { id: "x4", x: 1000, y: 300, w: 250, h: 150, type: "#action", shape: "Bolt", color: "Red", text: "eXterminate: Overcome rivals" }, { id: "x5", x: 550, y: 100, w: 300, h: 120, type: "#objective", shape: "Target", color: "Purple", text: "Galactic Domination" } ], links: [ { from: "x1", to: "x2", type: "enables" }, { from: "x2", to: "x3", type: "enables" }, { from: "x3", to: "x4", type: "enables" }, { from: "x5", to: "x1", type: "supports" }, { from: "x5", to: "x4", type: "supports" }] }
        };

        // --- Utility & Setup Functions ---
        function generateId() { return 'chunk-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9); }
        function showModal(modalElement) { modalElement.classList.remove('hidden'); }
        function hideModal(modalElement) { modalElement.classList.add('hidden'); }
        function showMessage(title, text, buttonsConfig = [{ text: 'OK', class: 'btn-primary', action: () => hideModal(messageModal) }]) {
            messageTitle.textContent = title; messageText.innerHTML = text; messageButtons.innerHTML = '';
            buttonsConfig.forEach(btnConfig => {
                const button = document.createElement('button');
                button.className = `btn ${btnConfig.class || 'btn-secondary'}`; button.textContent = btnConfig.text;
                button.onclick = () => { if (btnConfig.action) btnConfig.action(); if (!btnConfig.noHide) hideModal(messageModal); };
                messageButtons.appendChild(button);
            });
            showModal(messageModal);
        }
        function updateChunkCounter() { chunkCountDisplay.textContent = `Chunks: ${chunks.length}`; }

        function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
            selectElement.innerHTML = '';
            if (groups && groupLabelFormatterFn) {
                 for (const groupKey in groups) {
                    if (groups.hasOwnProperty(groupKey) && groups[groupKey].length > 0) {
                        const groupItems = groups[groupKey];
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = groupLabelFormatterFn(groupKey);
                        groupItems.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.tag; option.textContent = `${item.tag} - ${item.description}`;
                            if (item.tag === currentValue) option.selected = true;
                            optgroup.appendChild(option);
                        });
                        selectElement.appendChild(optgroup);
                    }
                }
            } else if (optionsArray) {
                optionsArray.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value; option.textContent = opt.text;
                    if (opt.value === currentValue) option.selected = true;
                    selectElement.appendChild(option);
                });
            }
        }
        
        // --- Theme Management ---
        function applyTheme(theme) {
            document.body.classList.remove('theme-dark', 'theme-blueprint', 'theme-camo', 'theme-wargaming', 'theme-warhammer', 'theme-space-strategy');
            if (theme && theme !== 'default') {
                document.body.classList.add(theme);
            }
            // Redraw connections and grid to apply new theme colors
            drawConnections();
            updateGrid();
        }

        function saveTheme(theme) {
            localStorage.setItem('chorusStrategistTheme', theme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('chorusStrategistTheme') || 'default';
            applyTheme(savedTheme);
        }

        function setupThemeSelector() {
            const themeSelector = document.getElementById('themeSelector');
            themeSelector.addEventListener('click', (e) => {
                const themeBtn = e.target.closest('.theme-btn');
                if (themeBtn) {
                    const theme = themeBtn.dataset.theme;
                    applyTheme(theme);
                    saveTheme(theme);
                }
            });
        }
        
        function populateHelpModal() {
            document.getElementById('shortcutsList').innerHTML = `
                <li><code>Ctrl/Cmd + S</code>: Save</li>
                <li><code>Ctrl/Cmd + O</code>: Load</li>
                <li><code>Ctrl/Cmd + Z</code>: Undo Delete</li>
                <li><code>A</code>: Add a new chunk</li>
                <li><code>Esc</code>: Close modals / Deselect</li>
                <li><code>Delete</code> / <code>Backspace</code>: Delete selected</li>`;
            document.getElementById('helpLinkTypes').innerHTML = LINK_TYPES.map(l => `<li><strong>${l.label}</strong>: A line with a <code>${l.style}</code> style.</li>`).join('');
            document.getElementById('helpCoreChunks').innerHTML = allChunkTypesList.map(c => `<li><code>${c.tag}</code>: ${c.description}</li>`).join('');
            document.getElementById('helpShapes').innerHTML = SHAPES.map(s => `<li><strong>${s.symbol} ${s.name}</strong>: ${s.meaning}</li>`).join('');
            document.getElementById('helpColors').innerHTML = COLORS.map(c => `<li><span class="${c.tailwindClass}">${c.symbol}</span> <strong>${c.name}</strong>: ${c.essence}</li>`).join('');
        }

        function populateAddChunkModal() { 
            populateSelectWithOptions(chunkTypeSelect, null, null, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types"); 
            populateSelectWithOptions(chunkShapeSelect, SHAPES.map(s => ({value: s.name, text: `${s.symbol} ${s.name} - ${s.meaning}`})), SHAPES[0].name); 
            populateSelectWithOptions(chunkColorSelect, COLORS.map(c => ({value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}`})), COLORS[0].name); 
        }

        function renderCustomTypesUI() {
            customTypesContainer.innerHTML = '';
            const allTypes = Object.values(chunkTypes).flat();
            allTypes.forEach(type => {
                const typeDiv = document.createElement('div');
                typeDiv.className = 'flex items-center justify-between text-sm p-1';
                typeDiv.innerHTML = `<span><span class="font-bold">${type.tag}</span>: ${type.description}</span>`;
                const isDefault = DEFAULT_CHUNK_TYPES.core.some(d => d.tag === type.tag) || DEFAULT_CHUNK_TYPES.secondary.some(d => d.tag === type.tag);
                if(!isDefault) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;'; deleteBtn.className = 'ml-4 text-red-500 font-bold hover:text-red-700'; deleteBtn.title = 'Delete this type';
                    deleteBtn.onclick = () => {
                        showMessage(
                            "Confirm Delete",
                            `Are you sure you want to delete the chunk type "${type.tag}"? This cannot be undone.`,
                            [
                                { text: 'Cancel', class: 'btn-secondary' },
                                { text: 'Delete', class: 'btn-danger', action: () => {
                                    for (const group in chunkTypes) { 
                                        chunkTypes[group] = chunkTypes[group].filter(t => t.tag !== type.tag);
                                    }
                                    saveCustomChunkTypes();
                                }}
                            ]
                        );
                    };
                    typeDiv.appendChild(deleteBtn);
                }
                customTypesContainer.appendChild(typeDiv);
            });
        }
        
        function loadCustomChunkTypes() {
            try {
                const storedTypes = localStorage.getItem('chorusStrategistChunkTypes');
                if(storedTypes) {
                    chunkTypes = JSON.parse(storedTypes);
                } else {
                    chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES)); // Deep copy
                }
            } catch (e) {
                console.error("Could not load custom chunk types, reverting to default.", e);
                chunkTypes = JSON.parse(JSON.stringify(DEFAULT_CHUNK_TYPES));
            }
            allChunkTypesList = Object.values(chunkTypes).flat();
            renderCustomTypesUI();
            populateHelpModal();
        }
        function saveCustomChunkTypes() {
            try {
                localStorage.setItem('chorusStrategistChunkTypes', JSON.stringify(chunkTypes));
                 allChunkTypesList = Object.values(chunkTypes).flat();
                 renderCustomTypesUI();
                 populateHelpModal();
                 populateAddChunkModal();
                 if (!editChunkModal.classList.contains('hidden')) {
                     const chunkId = editingChunkIdInput.value;
                     if(chunkId) openEditChunkModal(chunkId);
                 }
            } catch (e) { console.error("Could not save custom chunk types.", e); showMessage("Error", "Could not save custom chunk types to local storage."); }
        }
        
        function toggleView() {
            currentView = (currentView === 'canvas') ? 'timeline' : 'canvas';
            if (currentView === 'timeline') {
                renderTimelineView();
                noteCanvasContainer.style.display = 'none';
                timelineView.style.display = 'block';
                viewToggleBtn.textContent = 'Canvas';
            } else {
                noteCanvasContainer.style.display = 'block';
                timelineView.style.display = 'none';
                viewToggleBtn.textContent = 'Timeline';
                applyTransform();
            }
        }
        
        function renderTimelineView() {
            timelineView.innerHTML = '';
            if (chunks.length === 0) {
                timelineView.innerHTML = '<p class="text-center p-8">No chunks to display in timeline.</p>';
                return;
            }

            const renderedChunks = [];
            const visited = new Set();
            const MAX_INDENT = 3;
            
            const allTargetIds = new Set();
            chunks.forEach(chunk => {
                if (chunk.links) {
                    chunk.links.forEach(link => allTargetIds.add(link.targetId));
                }
            });

            function traverse(chunkId, level) {
                if (!chunkId || visited.has(chunkId)) return;
                
                const chunk = chunksMap.get(chunkId);
                if (!chunk) return;

                visited.add(chunkId);
                renderedChunks.push({ chunk, level });

                if (chunk.links) {
                    chunk.links.forEach(link => {
                        traverse(link.targetId, Math.min(level + 1, MAX_INDENT));
                    });
                }
            }

            const startNodes = chunks.filter(chunk => !allTargetIds.has(chunk.id));
            startNodes.forEach(chunk => traverse(chunk.id, 0));
            chunks.forEach(chunk => { if (!visited.has(chunk.id)) { traverse(chunk.id, 0); } });

            renderedChunks.forEach(({ chunk, level }) => {
                const color = COLORS.find(c => c.name === chunk.colorName);
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.style.marginLeft = `${level * 2.5}rem`; 

                item.innerHTML = `
                    <div class="timeline-dot" style="background-color: var(--bg-primary); border-color: var(--text-secondary)"></div>
                    <div class="timeline-content">
                        <div class="timeline-header">${chunk.chunkTypeTag}</div>
                        <div class="timeline-meta">${chunk.shapeSymbol || ''} ${chunk.shapeName} &bull; <span class="${color?.tailwindClass || ''}">${color?.symbol || ''} ${chunk.colorName}</span></div>
                        <div>${chunk.text}</div>
                    </div>
                `;
                const dot = item.querySelector('.timeline-dot');
                if(color) {
                   const colorMap = {"Red": "#ef4444", "Blue": "#3b82f6", "Green": "#22c55e", "Yellow": "#eab308", "Purple":"#8b5cf6", "Grey": "#6b7280", "Black": "#1f2937", "White": "#f3f4f6"};
                   dot.style.borderColor = colorMap[color.name] || '#6b7280';
                }

                timelineView.appendChild(item);
            });
        }


        function setupLayerControls() {
            layerControl.innerHTML = '';
            COLORS.forEach(color => {
                layerVisibility[color.name] = true;
                const label = document.createElement('label');
                label.innerHTML = `<input type="checkbox" data-color="${color.name}" checked> <span class="${color.tailwindClass}">${color.symbol}</span> ${color.name}`;
                layerControl.appendChild(label);
            });
            layerControl.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const colorName = e.target.dataset.color;
                    layerVisibility[colorName] = e.target.checked;
                    updateLayerVisibility();
                }
            });
        }
        function updateLayerVisibility() {
            chunks.forEach(chunk => {
                const isVisible = layerVisibility[chunk.colorName];
                const chunkEl = document.getElementById(chunk.id);
                if (chunkEl) { chunkEl.classList.toggle('hidden-by-layer', !isVisible); }
            });
            drawConnections();
        }

        function setupTemplateModal() {
            templateList.innerHTML = '';
            for (const key in STRATEGIC_TEMPLATES) {
                const template = STRATEGIC_TEMPLATES[key];
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary w-full text-left justify-start';
                btn.innerHTML = `<div><div class="font-bold">${template.name}</div><div class="text-sm font-normal">${template.description}</div></div>`;
                btn.onclick = () => {
                    showMessage("Confirm Load Template", `This will clear the current canvas. Are you sure you want to load the "${template.name}" template?`, [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load Template', class: 'btn-primary', action: () => { loadTemplate(template); hideModal(templatesModal); } } ]);
                };
                templateList.appendChild(btn);
            }
        }
        
        function loadTemplate(template) {
            if (!template) return;

            renderBoard([]); // Clear board first

            const loadedChunksData = [];
            const idMap = new Map();

            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            template.chunks.forEach(chunkTmpl => {
                minX = Math.min(minX, chunkTmpl.x);
                minY = Math.min(minY, chunkTmpl.y);
                maxX = Math.max(maxX, chunkTmpl.x + (chunkTmpl.w || 250));
                maxY = Math.max(maxY, chunkTmpl.y + (chunkTmpl.h || 150));
            });
            const templateWidth = maxX - minX;
            const templateHeight = maxY - minY;

            const viewportRect = noteCanvasContainer.getBoundingClientRect();
            const viewportCenterX = (viewportRect.width / 2);
            const viewportCenterY = (viewportRect.height / 2);
            const worldCenter = screenToWorld(viewportCenterX, viewportCenterY);

            const offsetX = worldCenter.x - (minX + templateWidth / 2);
            const offsetY = worldCenter.y - (minY + templateHeight / 2);

            template.chunks.forEach(chunkTmpl => {
                const chunkType = allChunkTypesList.find(ct => ct.tag === chunkTmpl.type);
                const shape = SHAPES.find(s => s.name === chunkTmpl.shape);
                const color = COLORS.find(c => c.name === chunkTmpl.color);
                if(!chunkType || !shape || !color) { console.warn("Skipping template chunk with invalid properties:", chunkTmpl); return; }
                const newId = generateId();
                if(chunkTmpl.id) idMap.set(chunkTmpl.id, newId);
                
                const newChunkData = {
                    id: newId,
                    chunkTypeTag: chunkTmpl.type,
                    shapeName: chunkTmpl.shape, shapeSymbol: shape.symbol,
                    colorName: chunkTmpl.color, colorSymbol: color.symbol, colorTailwindClass: color.tailwindClass,
                    text: chunkTmpl.text || '...',
                    x: chunkTmpl.x + offsetX,
                    y: chunkTmpl.y + offsetY,
                    width: chunkTmpl.w || 250, height: chunkTmpl.h || 150,
                    zIndex: ++highestZIndex,
                    links: []
                };
                loadedChunksData.push(newChunkData);
            });

            if (template.links) {
                template.links.forEach(link => {
                    const sourceId = idMap.get(link.from); const targetId = idMap.get(link.to);
                    const sourceChunk = loadedChunksData.find(c => c.id === sourceId);
                    if(sourceChunk && targetId) { 
                        sourceChunk.links.push({
                            targetId: targetId,
                            label: link.label || '',
                            type: link.type || 'enables'
                        }); 
                    }
                });
            }
            
            renderBoard(loadedChunksData);
        }

        function applyTransform() {
            if (!transformUpdateQueued) {
                transformUpdateQueued = true;
                requestAnimationFrame(() => {
                    transformContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    svgCanvas.setAttribute('width', String(noteCanvas.scrollWidth));
                    svgCanvas.setAttribute('height', String(noteCanvas.scrollHeight));
                    drawConnections();
                    updateGrid();
                    // Keep center marker at a constant size relative to the screen
                    if (centerMarker) {
                        centerMarker.style.transform = `translate(-50%, -50%) scale(${1 / scale})`;
                    }
                    transformUpdateQueued = false;
                });
            }
        }
        function resetAndCenterView() { scale = 1; const viewportWidth = noteCanvasContainer.clientWidth; const viewportHeight = noteCanvasContainer.clientHeight; const canvasContentWidth = noteCanvas.scrollWidth; const canvasContentHeight = noteCanvas.scrollHeight; translateX = (viewportWidth - canvasContentWidth * scale) / 2; translateY = (viewportHeight - canvasContentHeight * scale) / 2; applyTransform(); }
        function screenToWorld(screenX, screenY) { const containerRect = noteCanvasContainer.getBoundingClientRect(); const rectLeft = containerRect.left || 0; const rectTop = containerRect.top || 0; const worldX = (screenX - rectLeft - translateX) / scale; const worldY = (screenY - rectTop - translateY) / scale; return { x: worldX, y: worldY }; }
        function getPointerCoordinates(e) { if (e.touches && e.touches.length > 0) { return { x: e.touches[0].clientX, y: e.touches[0].clientY, count: e.touches.length }; } return { x: e.clientX, y: e.clientY, count: e.buttons === 1 ? 1 : 0 }; }
        
        function centerOnChunk(chunkId, setScaleToOne = true) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) return;

            if (setScaleToOne) {
                scale = 1;
            }

            const viewportWidth = noteCanvasContainer.clientWidth;
            const viewportHeight = noteCanvasContainer.clientHeight;

            const chunkCenterX = chunkData.x + chunkData.width / 2;
            const chunkCenterY = chunkData.y + chunkData.height / 2;

            translateX = (viewportWidth / 2) - (chunkCenterX * scale);
            translateY = (viewportHeight / 2) - (chunkCenterY * scale);

            applyTransform();
        }

        function loadApiKey() { const key = localStorage.getItem('geminiApiKey'); if (key) { geminiApiKey = key; geminiApiKeyInput.value = key; } }
		function saveApiKey() { 
			const key = geminiApiKeyInput.value.trim(); 
			if (key) { 
				geminiApiKey = key; 
				localStorage.setItem('geminiApiKey', key); 
				showMessage("API Key Saved", "Your Gemini API key has been saved locally."); 
			} else { 
				localStorage.removeItem('geminiApiKey'); 
				geminiApiKey = null; 
				// The showMessage call for clearing the key is removed.
			} 
		}        
        function loadDisplaySettings() {
            const gridSetting = localStorage.getItem('chorusShowGrid');
            showGrid = gridSetting === null ? true : JSON.parse(gridSetting);
            gridToggle.checked = showGrid;
            
            const markerSetting = localStorage.getItem('chorusShowCenterMarker');
            showCenterMarker = markerSetting === null ? false : JSON.parse(markerSetting);
            centerMarkerToggle.checked = showCenterMarker;
            
            updateGrid();
            updateCenterMarkerDisplay();
        }

        function saveDisplaySettings() {
            localStorage.setItem('chorusShowGrid', JSON.stringify(showGrid));
            localStorage.setItem('chorusShowCenterMarker', JSON.stringify(showCenterMarker));
        }

        function updateGrid() {
            if (!showGrid) {
                noteCanvasContainer.style.backgroundImage = '';
                return;
            }
            
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--canvas-grid-primary').trim();
            let baseSpacing = 40;
            
            let majorGridSize = baseSpacing * scale;
            while (majorGridSize < 25) { 
                majorGridSize *= 4;
            }
            while (majorGridSize > 100) {
                majorGridSize /= 4;
            }
            
            let minorGridSize = majorGridSize / 4;
            
            const isBlueprint = document.body.classList.contains('theme-blueprint');
            
            if (isBlueprint && minorGridSize > 5) {
                const minorColor = 'rgba(56, 189, 248, 0.1)';
                noteCanvasContainer.style.backgroundImage = `
                    linear-gradient(${gridColor} 1px, transparent 1px),
                    linear-gradient(to right, ${gridColor} 1px, transparent 1px),
                    linear-gradient(${minorColor} 1px, transparent 1px),
                    linear-gradient(to right, ${minorColor} 1px, transparent 1px)
                `;
                noteCanvasContainer.style.backgroundSize = `${majorGridSize}px ${majorGridSize}px, ${majorGridSize}px ${majorGridSize}px, ${minorGridSize}px ${minorGridSize}px, ${minorGridSize}px ${minorGridSize}px`;
                noteCanvasContainer.style.backgroundPosition = `${translateX}px ${translateY}px, ${translateX}px ${translateY}px, ${translateX}px ${translateY}px, ${translateX}px ${translateY}px`;
            } else {
                noteCanvasContainer.style.backgroundImage = `
                    linear-gradient(to right, ${gridColor} 1px, transparent 1px),
                    linear-gradient(to bottom, ${gridColor} 1px, transparent 1px)
                `;
                noteCanvasContainer.style.backgroundSize = `${majorGridSize}px ${majorGridSize}px`;
                noteCanvasContainer.style.backgroundPosition = `${translateX}px ${translateY}px`;
            }

             if (majorGridSize < 5) {
                noteCanvasContainer.style.backgroundImage = 'none';
            }
        }

        function updateCenterMarkerDisplay() {
            centerMarker.classList.toggle('hidden', !showCenterMarker);
        }

        async function callGemini(prompt, buttonToLoad) { if (!geminiApiKey) { showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); return null; } if (buttonToLoad) setButtonLoading(buttonToLoad, true); const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`; try { const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }), }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`); } const data = await response.json(); if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) { return data.candidates[0].content.parts[0].text; } else { if(data.candidates && data.candidates[0].finishReason === 'SAFETY') { throw new Error("The response was blocked due to safety settings. Please adjust your prompt."); } throw new Error("Received an empty or invalid response from the AI."); } } catch (error) { showMessage("AI Error", `An error occurred: ${error.message}`); console.error("Gemini API call failed:", error); return null; } finally { if (buttonToLoad) setButtonLoading(buttonToLoad, false); } }
        function openAiModal(chunkId) { if (!geminiApiKey) { showMessage("API Key Required", "Please enter your Google AI API key in the Settings modal first.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Open Settings', class: 'btn-primary', action: () => showModal(settingsModal) } ]); return; } activeAiChunkId = chunkId; aiPromptTextarea.value = ''; showModal(aiActionModal); aiPromptTextarea.focus(); }
        async function summarizeBoard() { if (chunks.length === 0) { showMessage("Empty Board", "There's nothing on the board to summarize."); return; } const allText = getCombinedTextForExport('txt'); const prompt = `Please provide a concise, high-level summary of the following strategic notes. Distill the main objectives, key assets and threats, and overall strategic direction. NOTES:\n${allText}`; const summary = await callGemini(prompt, summarizeBtn); if (summary) { const formattedSummary = summary.replace(/\n/g, '<br>'); showMessage("Board Summary", formattedSummary); } }
        async function handleSuggestNextChunk() {
             const sourceChunkData = chunksMap.get(activeAiChunkId);
             if (!sourceChunkData) { showMessage("Error", "Could not find source chunk."); return; }
             const prompt = `Based on the following text from a strategic planning note, suggest the content for a new, subsequent note that logically follows it. Provide ONLY the text for the new note itself, without any introductory phrases. CONTEXT:\n${sourceChunkData.text}`;
             const newText = await callGemini(prompt, aiActionSuggestNextBtn);
             if (newText) {
                 const newChunkDetails = { type: allChunkTypesList.find(ct => ct.tag === "#action") || allChunkTypesList[0], shape: SHAPES.find(s => s.name === "Square") || SHAPES[0], color: COLORS.find(c => c.name === "Grey") || COLORS[0], };
                 const newChunkOptions = { text: `<p>${newText.replace(/\n/g, '<br>')}</p>`, x: sourceChunkData.x + sourceChunkData.width + 40, y: sourceChunkData.y };
                 const newChunkData = addChunkToCanvas(newChunkDetails, newChunkOptions);
                 addOrUpdateLink(sourceChunkData.id, newChunkData.id, 'Follow-on action', 'enables');
                 centerOnChunk(newChunkData.id, true);
                 hideModal(aiActionModal);
                 showMessage("AI Suggestion", "A new chunk has been created and linked based on your previous note.");
             }
         }

        function openEditChunkModal(chunkId) {
            const chunkData = chunksMap.get(chunkId);
            if (!chunkData) {
                showMessage("Error", "Could not find the chunk to edit.");
                return;
            }
            editingChunkIdInput.value = chunkId;
            populateSelectWithOptions(editChunkTypeSelect, null, chunkData.chunkTypeTag, chunkTypes, key => key.charAt(0).toUpperCase() + key.slice(1) + " Types");
            populateSelectWithOptions(editChunkShapeSelect, SHAPES.map(s => ({ value: s.name, text: `${s.symbol} ${s.name} - ${s.meaning}` })), chunkData.shapeName);
            populateSelectWithOptions(editChunkColorSelect, COLORS.map(c => ({ value: c.name, text: `${c.symbol} ${c.name} - ${c.essence}` })), chunkData.colorName);
            const manageBtn = document.getElementById('manageLinksBtn');
            manageBtn.onclick = () => { hideModal(editChunkModal); openUnlinkModal(chunkId); };
            manageBtn.style.display = (chunkData.links && chunkData.links.length > 0) ? 'inline-flex' : 'none';
            showModal(editChunkModal);
        }

        function updateChunkHeaderDisplay(chunkId) {
            const chunkElement = document.getElementById(chunkId);
            const chunkData = chunksMap.get(chunkId);
            if (!chunkElement || !chunkData) return;
        
            const headerTitle = chunkElement.querySelector('.chunk-header-title');
            if (headerTitle) {
                const selectedShape = SHAPES.find(s => s.name === chunkData.shapeName) || {};
                const selectedColor = COLORS.find(c => c.name === chunkData.colorName) || {};
                const colorEssenceShort = selectedColor.essence ? selectedColor.essence.split(',')[0] : '';
        
                headerTitle.innerHTML = `
                    <div class="chunk-header-main">
                        <span class="tag">${chunkData.chunkTypeTag}</span> | 
                        <span class="shape-symbol" title="${selectedShape.meaning || ''}">${selectedShape.symbol || ''}</span>
                        <div class="color-symbol-container" title="${selectedColor.essence || ''}">
                            <span class="color-symbol ${selectedColor.tailwindClass || ''}">${selectedColor.symbol || ''}</span>
                            <span>${colorEssenceShort}</span>
                        </div>
                    </div>
                    <div class="chunk-header-sub">
                        <span>${selectedShape.meaning || ''}</span>
                    </div>
                `;
            }
        }

        function updateSelectedVisuals() { document.querySelectorAll('.chorus-chunk').forEach(el => { const chunkData = chunksMap.get(el.id); if (!chunkData) return; const isSelected = el.id === selectedChunkId; const isLinkingSource = el.id === linkingSourceChunkId; el.classList.toggle('selected-chunk', isSelected && !linkingMode); el.classList.toggle('linking-source-chunk', isLinkingSource && linkingMode); const linkButton = el.querySelector('.link-chunk-btn'); if (linkButton) { if (isLinkingSource && linkingMode) { linkButton.innerHTML = ICON_LINKING_ACTIVE; linkButton.title = 'Cancel Linking'; linkButton.classList.add('linking-active'); } else { linkButton.innerHTML = ICON_LINK; linkButton.title = 'Add Relationship'; linkButton.classList.remove('linking-active'); } } }); }
        
        function selectChunk(chunkId) { 
            selectedChunkId = chunkId; 
            updateSelectedVisuals();
        }
        function deselectAllChunks() { 
            const wasLinking = linkingMode; 
            if (wasLinking) { 
                cancelLinkingMode(true); 
            } 
            selectedChunkId = null; 
            if (!wasLinking) { 
                updateSelectedVisuals(); 
            }
        }

        function createChunkElement(chunkData) {
            const chunkDiv = document.createElement('div');
            chunkDiv.id = chunkData.id; chunkDiv.className = 'chorus-chunk';
            chunkDiv.style.left = chunkData.x + 'px'; chunkDiv.style.top = chunkData.y + 'px'; chunkDiv.style.width = chunkData.width + 'px'; chunkDiv.style.height = chunkData.height + 'px'; chunkDiv.style.zIndex = String(chunkData.zIndex);
            const isVisible = layerVisibility[chunkData.colorName];
            chunkDiv.classList.toggle('hidden-by-layer', !isVisible);
            chunkDiv.addEventListener('click', (e) => { const clickedChunkId = chunkData.id; if (linkingMode) { e.stopPropagation(); if (linkingSourceChunkId && linkingSourceChunkId !== clickedChunkId) { completeLink(linkingSourceChunkId, clickedChunkId); } else if (linkingSourceChunkId === clickedChunkId) { if (!e.target.closest('.chunk-action-btn')) { cancelLinkingMode(false); } } return; } const isInteractiveElement = e.target.closest('.chunk-action-btn') || e.target.closest('.chunk-content') || e.target.closest('.resize-handle'); if (!isInteractiveElement) { selectChunk(clickedChunkId); } });
            const header = document.createElement('div'); header.className = 'chunk-header'; header.addEventListener('mousedown', onInteractionStart); header.addEventListener('touchstart', onInteractionStart, { passive: false });
            const headerTitle = document.createElement('span'); headerTitle.className = 'chunk-header-title';
            const actionsContainer = document.createElement('div'); actionsContainer.className = 'chunk-actions';

            const aiBtn = document.createElement('button'); aiBtn.className = 'chunk-action-btn ai-chunk-btn'; aiBtn.title = 'AI Assistant'; aiBtn.innerHTML = ICON_AI_SPARKLE;
            const handleAiButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openAiModal(chunkData.id); };
            aiBtn.addEventListener('click', handleAiButtonAction);
            aiBtn.addEventListener('touchend', handleAiButtonAction);
            
            const editBtn = document.createElement('button'); editBtn.className = 'chunk-action-btn edit-chunk-btn'; editBtn.title = 'Edit Chunk Properties'; editBtn.innerHTML = ICON_PENCIL_EDIT;
            const handleEditButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); openEditChunkModal(chunkData.id); };
            editBtn.addEventListener('click', handleEditButtonAction);
            editBtn.addEventListener('touchend', handleEditButtonAction);

            const linkBtn = document.createElement('button'); linkBtn.className = 'chunk-action-btn link-chunk-btn';
            const handleLinkButtonAction = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (linkingMode && linkingSourceChunkId === chunkData.id) {
                    cancelLinkingMode(false);
                } else {
                    startLinkingMode(chunkData.id);
                }
            };
            linkBtn.addEventListener('click', handleLinkButtonAction);
            linkBtn.addEventListener('touchend', handleLinkButtonAction);

            const deleteBtn = document.createElement('button'); deleteBtn.className = 'chunk-action-btn delete-chunk-btn'; deleteBtn.title = 'Delete Chunk'; deleteBtn.innerHTML = ICON_DELETE;
            const handleDeleteButtonAction = (e) => { e.preventDefault(); e.stopPropagation(); deleteChunk(chunkData.id); };
            deleteBtn.addEventListener('click', handleDeleteButtonAction);
            deleteBtn.addEventListener('touchend', handleDeleteButtonAction);

            actionsContainer.appendChild(aiBtn); actionsContainer.appendChild(editBtn); actionsContainer.appendChild(linkBtn); actionsContainer.appendChild(deleteBtn);
            header.appendChild(headerTitle); header.appendChild(actionsContainer);
            const content = document.createElement('div'); content.className = 'chunk-content'; content.contentEditable = true; content.innerHTML = chunkData.text;
            content.addEventListener('input', () => { 
                const currentChunkData = chunksMap.get(chunkDiv.id); 
                if (currentChunkData) { 
                    currentChunkData.text = content.innerHTML; 
                }
                debouncedPopulateChunkList();
            });
            content.addEventListener('focus', () => { highestZIndex++; chunkDiv.style.zIndex = String(highestZIndex); const currentChunkData = chunksMap.get(chunkDiv.id); if (currentChunkData) currentChunkData.zIndex = highestZIndex; if (!linkingMode) selectChunk(chunkData.id); });
            const resizeHandle = document.createElement('div'); resizeHandle.className = 'resize-handle'; resizeHandle.addEventListener('mousedown', onInteractionStart); resizeHandle.addEventListener('touchstart', onInteractionStart, { passive: false });
            chunkDiv.appendChild(header); chunkDiv.appendChild(content); chunkDiv.appendChild(resizeHandle);
            noteCanvas.appendChild(chunkDiv);
            updateChunkHeaderDisplay(chunkData.id); updateSelectedVisuals();
            return chunkDiv;
        }
        function deleteChunk(chunkId) {
            const chunkIndex = chunks.findIndex(c => c.id === chunkId);
            if (chunkIndex > -1) {
                lastDeletedChunk = JSON.parse(JSON.stringify(chunks[chunkIndex]));
                chunks.splice(chunkIndex, 1);
                chunksMap.delete(chunkId);
                chunks.forEach(c => {
                    if (c.links) {
                        c.links = c.links.filter(link => link.targetId !== chunkId);
                    }
                });
                undoDeleteBtn.disabled = false;
            }
            if (selectedChunkId === chunkId) deselectAllChunks();
            if (linkingSourceChunkId === chunkId) cancelLinkingMode(false);
            const chunkElement = document.getElementById(chunkId);
            if (chunkElement) noteCanvas.removeChild(chunkElement);
            drawConnections();
            updateChunkCounter();
            updateSelectedVisuals();
            populateChunkList();
        }
        function undoDeleteLastChunk() { 
            if (lastDeletedChunk) { 
                if (chunksMap.has(lastDeletedChunk.id)) { 
                    showMessage("Undo Failed", "A chunk with the same ID already exists. Cannot undo."); 
                    lastDeletedChunk = null; 
                    undoDeleteBtn.disabled = true; 
                    return; 
                } 
                chunks.push(lastDeletedChunk); 
                chunksMap.set(lastDeletedChunk.id, lastDeletedChunk); 
                createChunkElement(lastDeletedChunk); 
                drawConnections(); 
                selectChunk(lastDeletedChunk.id); 
                lastDeletedChunk = null; 
                undoDeleteBtn.disabled = true; 
                showMessage("Undo Successful", "The last deleted chunk has been restored."); 
                updateChunkCounter(); 
                populateChunkList();
            } else { 
                showMessage("Nothing to Undo", "No chunk deletion to undo."); 
            } 
        }
        function addChunkToCanvas(chunkDetails, options = {}) { 
            const viewportRect = noteCanvasContainer.getBoundingClientRect(); 
            const defaultWorldPos = screenToWorld( (viewportRect.left || 0) + (viewportRect.width || window.innerWidth) / 2, (viewportRect.top || 0) + (viewportRect.height || window.innerHeight) / 4 ); 
            const newChunkData = { 
                id: generateId(), 
                chunkTypeTag: chunkDetails.type.tag, 
                shapeName: chunkDetails.shape.name, 
                shapeSymbol: chunkDetails.shape.symbol, 
                colorName: chunkDetails.color.name, 
                colorSymbol: chunkDetails.color.symbol, 
                colorTailwindClass: chunkDetails.color.tailwindClass, 
                text: options.text || 'New chunk... Start typing!', 
                x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x), 
                y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y), 
                width: options.width || 250, 
                height: options.height || 150, 
                zIndex: ++highestZIndex, 
                links: [] 
            }; 
            chunks.push(newChunkData); 
            chunksMap.set(newChunkData.id, newChunkData); 
            createChunkElement(newChunkData); 
            selectChunk(newChunkData.id); 
            drawConnections(); 
            updateChunkCounter(); 
            populateChunkList();
            return newChunkData; 
        }

        function startLinkingMode(sourceId) { linkingMode = true; linkingSourceChunkId = sourceId; document.body.classList.add('linking-mode'); selectChunk(sourceId); }
        function cancelLinkingMode(cancelledByDeselectAll = false) { linkingMode = false; const prevSourceId = linkingSourceChunkId; linkingSourceChunkId = null; document.body.classList.remove('linking-mode'); if (cancelledByDeselectAll) { selectedChunkId = null; } else if (prevSourceId) { selectChunk(prevSourceId); } updateSelectedVisuals(); }
        function completeLink(sourceId, targetId) {
            if (sourceId === targetId) return;
            openLinkEditor(sourceId, targetId);
        }
        function addOrUpdateLink(sourceId, targetId, label, linkType) {
            const sourceChunk = chunksMap.get(sourceId);
            if (sourceChunk) {
                if (!sourceChunk.links) sourceChunk.links = [];
                const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
                if (existingLink) {
                    existingLink.label = label;
                    existingLink.type = linkType;
                } else {
                    sourceChunk.links.push({ targetId, label, type: linkType });
                }
            }
            drawConnections();
            updateSelectedVisuals();
        }

        function getIntersectionPointWithRect(rect, internalPoint, externalPoint) { const p1 = internalPoint; const p2 = externalPoint; const dx = p2.x - p1.x; const dy = p2.y - p1.y; if (dx === 0 && dy === 0) return p1; let tMin = Infinity; let intersection = null; const rectRight = rect.x + rect.width; const rectBottom = rect.y + rect.height; if (dx !== 0) { const t = (rect.x - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rect.x, y: y }; } } } } if (dx !== 0) { const t = (rectRight - p1.x) / dx; if (t > 1e-6) { const y = p1.y + t * dy; if (y >= rect.y && y <= rectBottom) { if (t < tMin) { tMin = t; intersection = { x: rectRight, y: y }; } } } } if (dy !== 0) { const t = (rect.y - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rect.y }; } } } } if (dy !== 0) { const t = (rectBottom - p1.y) / dy; if (t > 1e-6) { const x = p1.x + t * dx; if (x >= rect.x && x <= rectRight) { if (t < tMin) { tMin = t; intersection = { x: x, y: rectBottom }; } } } } return intersection || p1; }
        let svgDefsCreated = false;
        function ensureSvgDefs() { if (svgDefsCreated) return; const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker'); marker.setAttribute('id', 'arrowhead'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '10'); marker.setAttribute('refY', '5'); marker.setAttribute('markerUnits', 'strokeWidth'); marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto'); const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); path.classList.add('arrow-head'); marker.appendChild(path); defs.appendChild(marker); svgCanvas.appendChild(defs); svgDefsCreated = true; }
        
        function drawConnections() {
            ensureSvgDefs();
            const children = Array.from(svgCanvas.children);
            children.forEach(child => { if (child.tagName.toLowerCase() !== 'defs') { svgCanvas.removeChild(child); } });
            
            chunks.forEach(sourceChunkData => {
                if (sourceChunkData.links && sourceChunkData.links.length > 0) {
                    sourceChunkData.links.forEach(link => {
                        const targetChunkData = chunksMap.get(link.targetId);
                        if (!targetChunkData) return;
                        
                        const sourceEl = document.getElementById(sourceChunkData.id);
                        const targetEl = document.getElementById(link.targetId);
                        if (!sourceEl || !targetEl) return;

                        const isSourceVisible = layerVisibility[sourceChunkData.colorName];
                        const isTargetVisible = layerVisibility[targetChunkData.colorName];

                        const sourceRect = { x: sourceEl.offsetLeft, y: sourceEl.offsetTop, width: sourceEl.offsetWidth, height: sourceEl.offsetHeight };
                        const targetRect = { x: targetEl.offsetLeft, y: targetEl.offsetTop, width: targetEl.offsetWidth, height: targetEl.offsetHeight };
                        const sourceCenter = { x: sourceRect.x + sourceRect.width / 2, y: sourceRect.y + sourceRect.height / 2 };
                        const targetCenter = { x: targetRect.x + targetRect.width / 2, y: targetRect.y + targetRect.height / 2 };
                        if (sourceCenter.x === targetCenter.x && sourceCenter.y === targetCenter.y) return;

                        const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter);
                        const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter);

                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', String(startPoint.x)); line.setAttribute('y1', String(startPoint.y));
                        line.setAttribute('x2', String(endPoint.x)); line.setAttribute('y2', String(endPoint.y));
                        line.classList.add('connecting-line');
                        line.classList.add(`link-type-${link.type || 'enables'}`);
                        line.setAttribute('marker-end', 'url(#arrowhead)');
                        line.classList.toggle('hidden-by-layer', !isSourceVisible || !isTargetVisible);
                        svgCanvas.appendChild(line);

                        if (link.label) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', String((startPoint.x + endPoint.x) / 2));
                            text.setAttribute('y', String((startPoint.y + endPoint.y) / 2));
                            text.classList.add('link-label');
                            text.textContent = link.label;
                            
                            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            rect.classList.add('link-label-bg');
                            
                            svgCanvas.appendChild(rect);
                            svgCanvas.appendChild(text);

                            try {
                                const bbox = text.getBBox();
                                rect.setAttribute('x', bbox.x - 4);
                                rect.setAttribute('y', bbox.y - 2);
                                rect.setAttribute('width', bbox.width + 8);
                                rect.setAttribute('height', bbox.height + 4);
                                rect.setAttribute('rx', 4);
                            } catch (e) {
                                console.warn("Could not get bounding box for link label.", e);
                            }
                        }
                    });
                }
            });
        }
        
        function openLinkEditor(sourceId, targetId, label = '', linkType = 'enables') {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk) return;

            linkSourceIdInput.value = sourceId;
            linkTargetIdInput.value = targetId;
            linkLabelInput.value = label;
            
            populateSelectWithOptions(linkTypeSelect, LINK_TYPES.map(l => ({value: l.type, text: l.label})), linkType);

            const existingLink = sourceChunk.links.find(l => l.targetId === targetId);
            linkEditTitle.textContent = existingLink ? 'Edit Relationship' : 'Create Relationship';
            confirmLinkEditBtn.textContent = existingLink ? 'Save Changes' : 'Create Link';
            
            showModal(linkEditModal);
        }

        function openUnlinkModal(sourceId) {
            const sourceChunk = chunksMap.get(sourceId);
            if (!sourceChunk || !sourceChunk.links || sourceChunk.links.length === 0) {
                showMessage("No Relationships", "This chunk has no outgoing relationships to manage.");
                return;
            }
            unlinkList.innerHTML = '';
            sourceChunk.links.forEach(link => {
                const targetChunk = chunksMap.get(link.targetId);
                if (targetChunk) {
                    const item = document.createElement('div');
                    item.className = 'flex justify-between items-center p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md';
                    
                    let labelText = link.label ? `"${link.label}"` : '(No note)';
                    let linkTypeName = (LINK_TYPES.find(lt => lt.type === link.type) || {label: link.type}).label;

                    item.innerHTML = `<div class="flex flex-col"><span class="font-semibold">To: ${targetChunk.chunkTypeTag}</span><span class="text-sm">${linkTypeName}: ${labelText}</span></div>`;
                    
                    const btnGroup = document.createElement('div');
                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn btn-secondary btn-sm !m-0 mr-2';
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => {
                         hideModal(unlinkModal);
                         openLinkEditor(sourceId, link.targetId, link.label, link.type);
                    };

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn btn-danger btn-sm !m-0';
                    removeBtn.textContent = 'Remove';
                    removeBtn.onclick = () => {
                        sourceChunk.links = sourceChunk.links.filter(l => l.targetId !== link.targetId);
                        item.remove();
                        drawConnections();
                        updateSelectedVisuals();
                        if (sourceChunk.links.length === 0) {
                            hideModal(unlinkModal);
                        }
                    };

                    btnGroup.appendChild(editBtn);
                    btnGroup.appendChild(removeBtn);
                    item.appendChild(btnGroup);
                    unlinkList.appendChild(item);
                }
            });
            showModal(unlinkModal);
        }

        function onInteractionStart(e) {
            if (linkingMode) return;

            const isTouchEvent = e.type.startsWith('touch');
            if (isTouchEvent && e.touches.length > 1) return;
            if (isTouchEvent) e.preventDefault();
            const pointer = getPointerCoordinates(e);
            interactionStartX = pointer.x;
            interactionStartY = pointer.y;
            if (e.target.classList.contains('resize-handle')) {
                currentAction = 'resize';
                resizingChunk = e.target.closest('.chorus-chunk');
                if (!resizingChunk) { currentAction = null; return; }
                e.stopPropagation();
                selectChunk(resizingChunk.id);
                highestZIndex++;
                resizingChunk.style.zIndex = String(highestZIndex);
                const chunkData = chunksMap.get(resizingChunk.id);
                if(chunkData) chunkData.zIndex = highestZIndex;
                startX = pointer.x;
                startY = pointer.y;
                startWidth = parseFloat(resizingChunk.style.width);
                startHeight = parseFloat(resizingChunk.style.height);
            } else if (e.target.closest('.chunk-header')) {
                if (e.target.closest('.chunk-action-btn')) return;
                currentAction = 'drag';
                draggedChunk = e.target.closest('.chorus-chunk');
                if (!draggedChunk) { currentAction = null; return; }
                e.stopPropagation();
                selectChunk(draggedChunk.id);
                highestZIndex++;
                draggedChunk.style.zIndex = String(highestZIndex);
                const chunkData = chunksMap.get(draggedChunk.id);
                if(chunkData) chunkData.zIndex = highestZIndex;
                const worldPointer = screenToWorld(pointer.x, pointer.y);
                offsetX = worldPointer.x - parseFloat(draggedChunk.style.left);
                offsetY = worldPointer.y - parseFloat(draggedChunk.style.top);
            }
            if (currentAction === 'drag' || currentAction === 'resize') {
                document.addEventListener('mousemove', onInteractionMove);
                document.addEventListener('mouseup', onInteractionEnd);
                document.addEventListener('touchmove', onInteractionMove, { passive: false });
                document.addEventListener('touchend', onInteractionEnd);
            }
        }
        let interactionMoveQueued = false;
        
        function onInteractionMove(e) {
            const isTouchEvent = e.type.startsWith('touch');
            if (!currentAction) return;
            if (isTouchEvent) e.preventDefault();
            if (interactionMoveQueued) return;
            interactionMoveQueued = true;
            
            requestAnimationFrame(() => {
                const pointer = getPointerCoordinates(e);
                
                if (currentAction === 'drag' && draggedChunk) {
                    const worldPointer = screenToWorld(pointer.x, pointer.y);
                    let newWorldX = worldPointer.x - offsetX;
                    let newWorldY = worldPointer.y - offsetY;
                    
                    const canvasWorldWidth = noteCanvas.scrollWidth;
                    const canvasWorldHeight = noteCanvas.scrollHeight;
                    const chunkWidth = parseFloat(draggedChunk.style.width);
                    const chunkHeight = parseFloat(draggedChunk.style.height);

                    newWorldX = Math.max(0, Math.min(newWorldX, canvasWorldWidth - chunkWidth));
                    newWorldY = Math.max(0, Math.min(newWorldY, canvasWorldHeight - chunkHeight));

                    draggedChunk.style.left = newWorldX + 'px';
                    draggedChunk.style.top = newWorldY + 'px';
                    drawConnections();

                } else if (currentAction === 'resize' && resizingChunk) {
                    const deltaScreenX = pointer.x - startX;
                    const deltaScreenY = pointer.y - startY;
                    let newWidth = startWidth + (deltaScreenX / scale);
                    let newHeight = startHeight + (deltaScreenY / scale);
                    
                    newWidth = Math.max(100, newWidth);
                    newHeight = Math.max(80, newHeight);
                    
                    const chunkCurrentX = parseFloat(resizingChunk.style.left);
                    const chunkCurrentY = parseFloat(resizingChunk.style.top);
                    const canvasWorldWidth = noteCanvas.scrollWidth;
                    const canvasWorldHeight = noteCanvas.scrollHeight;

                    if (chunkCurrentX + newWidth > canvasWorldWidth) {
                        newWidth = canvasWorldWidth - chunkCurrentX;
                    }
                    if (chunkCurrentY + newHeight > canvasWorldHeight) {
                        newHeight = canvasWorldHeight - chunkCurrentY;
                    }
                    
                    resizingChunk.style.width = newWidth + 'px';
                    resizingChunk.style.height = newHeight + 'px';
                    drawConnections();

                } else if (currentAction === 'pan') {
                    translateX = pointer.x - panStartX;
                    translateY = pointer.y - panStartY;
                    applyTransform();
                }
                
                interactionMoveQueued = false;
            });
        }

        function onInteractionEnd(e) { if (currentAction === 'drag' && draggedChunk) { const chunkData = chunksMap.get(draggedChunk.id); if (chunkData) { chunkData.x = parseFloat(draggedChunk.style.left); chunkData.y = parseFloat(draggedChunk.style.top); } draggedChunk = null; } else if (currentAction === 'resize' && resizingChunk) { const chunkData = chunksMap.get(resizingChunk.id); if (chunkData) { chunkData.width = parseFloat(resizingChunk.style.width); chunkData.height = parseFloat(resizingChunk.style.height); } resizingChunk = null; } else if (currentAction === 'pan') { noteCanvasContainer.classList.remove('panning'); } if (currentAction !== 'pinch-zoom') { currentAction = null; } document.removeEventListener('mousemove', onInteractionMove); document.removeEventListener('mouseup', onInteractionEnd); document.removeEventListener('touchmove', onInteractionMove); document.removeEventListener('touchend', onInteractionEnd); }
        
        function getCombinedTextForExport(format) {
            const tempDiv = document.createElement('div');
            function cleanTextForExport(html) {
                tempDiv.innerHTML = html.replace(/<br>/g, '\n').replace(/<p>/g, '').replace(/<\/p>/g, '\n\n');
                let text = (tempDiv.textContent || tempDiv.innerText || "").trim();
                if (format === 'csv' && (text.includes(',') || text.includes('"') || text.includes('\n'))) {
                    text = '"' + text.replace(/"/g, '""') + '"';
                }
                return text;
            }

            if (format === 'csv') {
                let csvContent = "id,type,shape,color,x,y,width,height,text,linked_to_ids,link_labels,link_types\n";
                chunks.forEach(chunk => {
                    const linkedTo = chunk.links.map(l => l.targetId).join(';');
                    const linkLabels = chunk.links.map(l => l.label || '').join(';');
                    const linkTypes = chunk.links.map(l => l.type).join(';');
                    const row = [
                        chunk.id,
                        chunk.chunkTypeTag,
                        chunk.shapeName,
                        chunk.colorName,
                        chunk.x, chunk.y, chunk.width, chunk.height,
                        cleanTextForExport(chunk.text),
                        linkedTo, linkLabels, linkTypes
                    ].join(',');
                    csvContent += row + '\n';
                });
                return csvContent;
            }

            let output = "";
            let visited = new Set();
            const allTargetIds = new Set(chunks.flatMap(c => c.links ? c.links.map(l => l.targetId) : []));
            const startNodes = chunks.filter(c => !allTargetIds.has(c.id));
            chunks.forEach(c => { if(!visited.has(c.id) && !startNodes.some(sn => sn.id === c.id)) { startNodes.push(c); } });

            function traverse(chunkId, prefix = "") {
                if (!chunkId || visited.has(chunkId)) return;
                
                const chunk = chunksMap.get(chunkId);
                if (!chunk) return;
                
                visited.add(chunkId);
                
                const textContent = cleanTextForExport(chunk.text);
                const shape = SHAPES.find(s => s.name === chunk.shapeName) || {};
                const color = COLORS.find(c => c.name === chunk.colorName) || {};

                const links = chunk.links && chunk.links.length > 0
                    ? chunk.links.map(link => {
                        const targetChunk = chunksMap.get(link.targetId);
                        const linkTypeInfo = LINK_TYPES.find(lt => lt.type === link.type);
                        let linkStr = `${linkTypeInfo ? linkTypeInfo.label : link.type}`;
                        if (link.label) linkStr += ` ("${link.label}")`;
                        linkStr += ` -> ${targetChunk ? targetChunk.chunkTypeTag : 'Unknown'}`;
                        return linkStr;
                      }).join(', ')
                    : "None";

                switch (format) {
                    case 'txt':
                        output += `${prefix}${chunk.chunkTypeTag}\n`;
                        output += `${prefix}Shape: ${chunk.shapeName} (${shape.meaning})\n`;
                        output += `${prefix}Color: ${chunk.colorName} (${color.essence})\n\n`;
                        output += `${prefix}${textContent}\n\n`;
                        output += `${prefix}Relationships: ${links}\n\n`;
                        output += `${prefix}--------------------------------\n\n`;
                        break;
                    case 'md':
                        output += `${prefix}## ${chunk.chunkTypeTag}\n\n`;
                        output += `${prefix}* **Shape**: ${chunk.shapeName} - ${shape.meaning}\n`;
                        output += `${prefix}* **Color**: ${chunk.colorName} - ${color.essence}\n\n`;
                        output += `${prefix}> ${textContent.replace(/\n/g, `\n${prefix}> `)}\n\n`;
                        if (links !== "None") {
                            output += `${prefix}**Relationships:**\n${prefix}- ${links.replace(/, /g, `\n${prefix}- `)}\n\n`;
                        }
                        output += `${prefix}---\n\n`;
                        break;
                    case 'html':
                        const linksHtml = links === "None" ? '<p>None</p>' : `<ul><li>${links.replace(/, /g, '</li><li>')}</li></ul>`;
                        output += `
                            <div class="chunk" style="border:1px solid #ccc; padding:15px; margin-bottom:20px; border-radius:8px; page-break-inside: avoid;">
                                <h3>${chunk.chunkTypeTag}</h3>
                                <div class="meta" style="font-size:0.9em; color:#555; margin-bottom:10px;">
                                    <p><strong>Shape:</strong> ${chunk.shapeName} - <em>${shape.meaning}</em></p>
                                    <p><strong>Color:</strong> ${chunk.colorName} - <em>${color.essence}</em></p>
                                </div>
                                <div class="content" style="margin-bottom:15px;">${chunk.text}</div>
                                <div class="links">
                                    <strong>Relationships:</strong>
                                    ${linksHtml}
                                </div>
                            </div>
                        `;
                        break;
                }
                
                if (chunk.links && chunk.links.length > 0) {
                    chunk.links.forEach((link) => {
                        traverse(link.targetId, prefix + "    ");
                    });
                }
            }

            startNodes.forEach(node => traverse(node.id));
            chunks.forEach(chunk => { if (!visited.has(chunk.id)) { traverse(chunk.id); } });

            if (format === 'html') {
                 return `<!DOCTYPE html><html><head><title>CHORUS Export</title><style>body{font-family:sans-serif;line-height:1.6;} .chunk{background:#f9f9f9;}</style></head><body><h1>CHORUS Export</h1>${output}</body></html>`;
            }

            return output;
        }

        function saveDataToFile() { chunks.forEach(chunkData => { const chunkElement = document.getElementById(chunkData.id); if (chunkElement) { const contentDiv = chunkElement.querySelector('.chunk-content'); if (contentDiv) { chunkData.text = contentDiv.innerHTML; } } }); if (chunks.length === 0) { showMessage("Empty Board", "There are no notes to save."); return; } setButtonLoading(saveBtn, true); try { const dataToSave = { chunks: chunks, viewport: { scale: scale, translateX: translateX, translateY: translateY } }; const dataStr = JSON.stringify(dataToSave, null, 2); downloadFile(dataStr, 'chorus-strategist-map.json', 'application/json'); showMessage('Saved to File', 'Your board has been prepared for download.'); } catch (error) { showMessage('Save Error', `Could not prepare data for saving: ${error.message}`); console.error("Save error:", error); } finally { setButtonLoading(saveBtn, false); } }
        
        function saveAsTemplate() {
            if (chunks.length === 0) {
                showMessage("Empty Board", "There is nothing on the board to save as a template.");
                return;
            }
        
            let templateChunks = JSON.parse(JSON.stringify(chunks));
        
            let minX = Infinity;
            let minY = Infinity;
            templateChunks.forEach(chunk => {
                minX = Math.min(minX, chunk.x);
                minY = Math.min(minY, chunk.y);
            });
        
            templateChunks.forEach(chunk => {
                chunk.x = chunk.x - minX + 50;
                chunk.y = chunk.y - minY + 50;
                delete chunk.zIndex;
            });
        
            const templateData = {
                name: "Custom Template",
                description: "A custom template saved from the board.",
                chunks: templateChunks.map(({ id, links, ...rest }) => rest),
                links: templateChunks.flatMap(chunk => 
                    (chunk.links || []).map(link => ({ from: chunk.id, to: link.targetId, ...link }))
                )
            };
        
            const idMap = new Map();
            let counter = 1;
            templateData.chunks.forEach(chunk => {
                const originalId = chunks.find(c => c.x === chunk.x + minX - 50 && c.y === chunk.y + minY - 50)?.id;
                if (originalId) {
                    idMap.set(originalId, `id${counter}`);
                    chunk.id = `id${counter}`;
                    counter++;
                }
            });

            templateData.links = templateData.links.map(link => ({
                from: idMap.get(link.from),
                to: idMap.get(link.to),
                type: link.type,
                label: link.label
            })).filter(link => link.from && link.to);

            const dataStr = JSON.stringify({ chunks: templateData.chunks, links: templateData.links }, null, 2);
            downloadFile(dataStr, 'chorus-custom-template.json', 'application/json');
            showMessage('Template Saved', 'Your custom template has been prepared for download.');
        }

        function downloadFile(content, fileName, contentType) { const a = document.createElement('a'); const file = new Blob([content], {type: contentType}); a.href = URL.createObjectURL(file); a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); }
        
        function renderBoard(loadedChunksData) {
            const existingChunkElements = noteCanvas.querySelectorAll('.chorus-chunk'); existingChunkElements.forEach(el => el.remove());
            chunks = loadedChunksData || []; chunksMap.clear(); highestZIndex = 0; selectedChunkId = null; lastDeletedChunk = null; undoDeleteBtn.disabled = true; cancelLinkingMode(true);
            if (Array.isArray(chunks)) { 
                chunks.forEach(chunkData => { 
                    if (chunkData.nextChunkIds && Array.isArray(chunkData.nextChunkIds)) {
                        chunkData.links = chunkData.nextChunkIds.map(targetId => ({ targetId: targetId, type: 'enables', label: '' }));
                        delete chunkData.nextChunkIds;
                    }
                    chunkData.links = chunkData.links || []; 

                    if (chunkData && chunkData.id && chunkData.chunkTypeTag && chunkData.shapeName && chunkData.colorName) { 
                        chunksMap.set(chunkData.id, chunkData); 
                        createChunkElement(chunkData); 
                        if (chunkData.zIndex > highestZIndex) { highestZIndex = chunkData.zIndex; } 
                    } else { 
                        console.warn("Skipping invalid chunk data during render:", chunkData); 
                    } 
                }); 
            }
            if(chunks.length === 0) highestZIndex = 1;
            updateSelectedVisuals(); 
            drawConnections(); 
            updateChunkCounter(); 
            updateLayerVisibility();
            populateChunkList();
        }

        const originalButtonStates = {};
        function setButtonLoading(button, isLoading) { if (!button) { return; } const buttonId = button.id || `btn-${Math.random()}`; button.id = buttonId; if (isLoading) { if (!originalButtonStates[buttonId]) { originalButtonStates[buttonId] = button.innerHTML; } button.innerHTML = `<svg class="animate-spin h-5 w-5 spinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`; button.classList.add('loading'); button.disabled = true; } else { if (originalButtonStates[buttonId] !== undefined) { button.innerHTML = originalButtonStates[buttonId]; delete originalButtonStates[buttonId]; } button.classList.remove('loading'); button.disabled = false; } }

        function setupDropdowns() {
            document.querySelectorAll('.dropdown').forEach(dropdown => {
                const trigger = dropdown.querySelector('button');
                const content = dropdown.querySelector('.dropdown-content');
                if (!trigger || !content) return;
                trigger.addEventListener('click', (event) => {
                    event.stopPropagation();
                    document.querySelectorAll('.dropdown-content.show').forEach(openContent => {
                        if (openContent !== content) {
                            openContent.classList.remove('show');
                        }
                    });
                    content.classList.toggle('show');
                });
                content.addEventListener('click', (event) => {
                    event.stopPropagation();
                });
            });
            window.addEventListener('click', () => {
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => {
                    openContent.classList.remove('show');
                });
            });
        }

        function debounce(func, timeout = 300){
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => { func.apply(this, args); }, timeout);
            };
        }
        const debouncedPopulateChunkList = debounce(() => populateChunkList(), 500);

        function populateChunkList() {
            chunkListDropdown.innerHTML = ''; 

            if (chunks.length === 0) {
                const noChunksItem = document.createElement('div');
                noChunksItem.className = 'px-4 py-2 text-sm text-[var(--text-secondary)]';
                noChunksItem.textContent = 'No chunks on canvas.';
                chunkListDropdown.appendChild(noChunksItem);
                return;
            }

            const sortedChunks = [...chunks].sort((a, b) => {
                const typeA = a.chunkTypeTag.toLowerCase();
                const typeB = b.chunkTypeTag.toLowerCase();
                if (typeA < typeB) return -1;
                if (typeA > typeB) return 1;
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = a.text;
                const textA = (tempDiv.textContent || tempDiv.innerText || "").trim().toLowerCase();
                tempDiv.innerHTML = b.text;
                const textB = (tempDiv.textContent || tempDiv.innerText || "").trim().toLowerCase();

                if (textA < textB) return -1;
                if (textA > textB) return 1;

                return 0;
            });

            sortedChunks.forEach(chunk => {
                const listItem = document.createElement('button');
                listItem.className = 'w-full text-left p-2 hover:bg-[var(--bg-primary)] rounded-md';
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = chunk.text;
                let cleanText = (tempDiv.textContent || tempDiv.innerText || "").trim();
                if (cleanText.length > 30) {
                    cleanText = cleanText.substring(0, 30) + '...';
                }

                listItem.innerHTML = `<div class="font-bold text-sm">${chunk.chunkTypeTag}</div><div class="text-xs text-[var(--text-secondary)]">${cleanText || '(no text)'}</div>`;
                
                listItem.addEventListener('click', () => {
                    centerOnChunk(chunk.id, false); 
                    chunkListDropdown.classList.remove('show');
                });
                chunkListDropdown.appendChild(listItem);
            });
        }

        // --- Initialization Sequence ---
        function initializeApp() {
            document.getElementById('copyrightYear').textContent = new Date().getFullYear();
            document.getElementById('copyrightYearHelp').textContent = new Date().getFullYear();
            
            loadTheme();
            loadApiKey(); 
            loadCustomChunkTypes();
            loadDisplaySettings(); 
            setupLayerControls(); 
            setupTemplateModal(); 
            populateAddChunkModal();
            setupDropdowns();
            setupThemeSelector();
            renderBoard([]);
            
            // Toolbar
            addChunkBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(addChunkModal); });
            templatesBtn.addEventListener('click', () => showModal(templatesModal));
            clearCanvasBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); if (chunks.length === 0) { showMessage("Canvas Empty", "The canvas is already clear."); return; } showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Clear Canvas', class: 'btn-danger', action: () => { renderBoard([]); populateChunkList(); showMessage("Canvas Cleared", "All notes and links have been removed."); }} ]); });
            undoDeleteBtn.addEventListener('click', () => { if (linkingMode) cancelLinkingMode(false); undoDeleteLastChunk(); });
            summarizeBtn.addEventListener('click', summarizeBoard);
            viewToggleBtn.addEventListener('click', toggleView);
            
            zoomInBtn.addEventListener('click', () => {
                const rect = noteCanvasContainer.getBoundingClientRect();
                const centerXRelative = rect.width / 2;
                const centerYRelative = rect.height / 2;
                const worldXBeforeZoom = (centerXRelative - translateX) / scale;
                const worldYBeforeZoom = (centerYRelative - translateY) / scale;
                let newScale = Math.min(MAX_SCALE, scale * 1.25);
                translateX = centerXRelative - worldXBeforeZoom * newScale;
                translateY = centerYRelative - worldYBeforeZoom * newScale;
                scale = newScale;
                applyTransform();
            });
            zoomOutBtn.addEventListener('click', () => {
                const rect = noteCanvasContainer.getBoundingClientRect();
                const centerXRelative = rect.width / 2;
                const centerYRelative = rect.height / 2;
                const worldXBeforeZoom = (centerXRelative - translateX) / scale;
                const worldYBeforeZoom = (centerYRelative - translateY) / scale;
                let newScale = Math.max(MIN_SCALE, scale / 1.25);
                translateX = centerXRelative - worldXBeforeZoom * newScale;
                translateY = centerYRelative - worldYBeforeZoom * newScale;
                scale = newScale;
                applyTransform();
            });

            zoomResetBtn.addEventListener('click', resetAndCenterView);
            saveBtn.addEventListener('click', saveDataToFile);
            loadBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); if (chunks.length > 0) { showMessage("Confirm Load", "Loading a new file will clear any unsaved changes on the current canvas. Are you sure you want to proceed?", [ { text: 'Cancel', class: 'btn-secondary' }, { text: 'Load File', class: 'btn-primary', action: () => fileLoadInput.click() } ]); } else { fileLoadInput.click(); } });
            settingsBtn.addEventListener('click', () => showModal(settingsModal));
            helpBtn.addEventListener('click', () => { if(linkingMode) cancelLinkingMode(false); showModal(helpModal); });
            donateBtn.addEventListener('click', () => showModal(supportModal));
            
            // Export Button Events
            exportTxtBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('txt'), 'chorus-export.txt', 'text/plain;charset=utf-8');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportMdBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('md'), 'chorus-export.md', 'text/markdown;charset=utf-8');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportHtmlBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('html'), 'chorus-export.html', 'text/html;charset=utf-8');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportJsonBtn.addEventListener('click', () => {
                const dataToSave = { chunks: chunks, viewport: { scale: scale, translateX: translateX, translateY: translateY } };
                downloadFile(JSON.stringify(dataToSave, null, 2), 'chorus-export.json', 'application/json');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });
            exportCsvBtn.addEventListener('click', () => {
                downloadFile(getCombinedTextForExport('csv'), 'chorus-export.csv', 'text/csv;charset=utf-8');
                document.querySelectorAll('.dropdown-content.show').forEach(openContent => openContent.classList.remove('show'));
            });

            // Custom Template Button Events
            saveAsTemplateBtn.addEventListener('click', saveAsTemplate);
            loadCustomTemplateBtn.addEventListener('click', () => customTemplateLoadInput.click());
            
            // Modals
            cancelAddChunkBtn.addEventListener('click', () => hideModal(addChunkModal));
            confirmAddChunkBtn.addEventListener('click', () => { 
                const selectedType = allChunkTypesList.find(ct => ct.tag === chunkTypeSelect.value); 
                const selectedShape = SHAPES.find(s => s.name === chunkShapeSelect.value); 
                const selectedColor = COLORS.find(c => c.name === chunkColorSelect.value); 
                if (!selectedType || !selectedShape || !selectedColor) { 
                    showMessage('Error', 'Please make a selection for all properties.'); 
                    return; 
                } 
                const newChunkData = addChunkToCanvas({ type: selectedType, shape: selectedShape, color: selectedColor }); 
                centerOnChunk(newChunkData.id, true);
                hideModal(addChunkModal); 
            });
            cancelEditChunkBtn.addEventListener('click', () => hideModal(editChunkModal));
            confirmEditChunkBtn.addEventListener('click', () => { const chunkId = editingChunkIdInput.value; const chunkData = chunksMap.get(chunkId); if (!chunkData) return; const newType = allChunkTypesList.find(ct => ct.tag === editChunkTypeSelect.value); const newShape = SHAPES.find(s => s.name === editChunkShapeSelect.value); const newColor = COLORS.find(c => c.name === editChunkColorSelect.value); if (!newType || !newShape || !newColor) { showMessage('Error', 'Invalid selection.'); return; } chunkData.chunkTypeTag = newType.tag; chunkData.shapeName = newShape.name; chunkData.shapeSymbol = newShape.symbol; chunkData.colorName = newColor.name; chunkData.colorSymbol = newColor.symbol; chunkData.colorTailwindClass = newColor.tailwindClass; updateChunkHeaderDisplay(chunkId); hideModal(editChunkModal); updateSelectedVisuals(); updateLayerVisibility(); drawConnections(); populateChunkList(); });
            cancelSettingsBtn.addEventListener('click', () => hideModal(settingsModal));
            closeSettingsModalBtn.addEventListener('click', () => hideModal(settingsModal));
            saveSettingsBtn.addEventListener('click', () => { saveApiKey(); saveCustomChunkTypes(); saveDisplaySettings(); hideModal(settingsModal); });
            addCustomTypeForm.addEventListener('submit', (e) => { e.preventDefault(); const tag = customTypeTagInput.value.trim(); const desc = customTypeDescInput.value.trim(); if (!tag.startsWith('#') || tag.length < 2 || !desc) { showMessage("Invalid Input", "Custom types must start with # and have a description."); return; } if(allChunkTypesList.some(t => t.tag === tag)){ showMessage("Duplicate Tag", "A chunk type with this tag already exists."); return; } if(!chunkTypes.custom) chunkTypes.custom = []; chunkTypes.custom.push({ tag, description: desc }); saveCustomChunkTypes(); customTypeTagInput.value = ''; customTypeDescInput.value = ''; });
            cancelAiActionBtn.addEventListener('click', () => hideModal(aiActionModal));
            closeAiActionModalBtn.addEventListener('click', () => hideModal(aiActionModal));
            aiActionSuggestNextBtn.addEventListener('click', handleSuggestNextChunk);
            aiActionGenerateBtn.addEventListener('click', async () => { const promptText = aiPromptTextarea.value.trim(); if (!promptText) { showMessage("Prompt Required", "Please enter a prompt for the AI."); return; } const chunkData = chunksMap.get(activeAiChunkId); if (!chunkData) { showMessage("Error", "Could not find the active chunk."); return; } const contentDiv = document.getElementById(activeAiChunkId)?.querySelector('.chunk-content'); if(!contentDiv) return; const fullPrompt = `CONTEXT:\n${contentDiv.innerText}\n\nPROMPT:\n${promptText}\n\nINSTRUCTIONS: Respond with only the generated text, without any introductory phrases or markdown.`; const result = await callGemini(fullPrompt, aiActionGenerateBtn); if (result !== null) { let htmlResult = result.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>'); htmlResult = `<p>${htmlResult}</p>`; contentDiv.innerHTML = htmlResult; chunkData.text = htmlResult; hideModal(aiActionModal); showMessage("Content Updated", "The chunk content has been updated by the AI."); } });
            closeHelpBtn.addEventListener('click', () => hideModal(helpModal));
            closeHelpModalSpan.addEventListener('click', () => hideModal(helpModal));
            closeUnlinkModalBtn.addEventListener('click', () => hideModal(unlinkModal));
            
            gridToggle.addEventListener('change', () => { showGrid = gridToggle.checked; updateGrid(); });
            centerMarkerToggle.addEventListener('change', () => { showCenterMarker = centerMarkerToggle.checked; updateCenterMarkerDisplay(); });

            cancelLinkEditBtn.addEventListener('click', () => { hideModal(linkEditModal); cancelLinkingMode(false); });
            confirmLinkEditBtn.addEventListener('click', () => {
                const sourceId = linkSourceIdInput.value;
                const targetId = linkTargetIdInput.value;
                const label = linkLabelInput.value;
                const type = linkTypeSelect.value;
                addOrUpdateLink(sourceId, targetId, label, type);
                hideModal(linkEditModal);
                cancelLinkingMode(false);
            });
            
            // File Load listener
            const fileLoadHandler = (file, buttonToLoad, isTemplate) => {
                if (!file) return;
                if (file.type !== "application/json") {
                    showMessage("Load Error", "Invalid file type. Please select a .json file.");
                    return;
                }
                if(buttonToLoad) setButtonLoading(buttonToLoad, true);
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedData = JSON.parse(e.target.result);
                        if (isTemplate) {
                            if (loadedData && Array.isArray(loadedData.chunks)) {
                                loadTemplate(loadedData);
                                hideModal(templatesModal);
                                showMessage('Template Loaded', `Successfully loaded custom template from ${file.name}.`);
                            } else {
                                throw new Error("Invalid template file format. Expected 'chunks' array.");
                            }
                        } else {
                             if (loadedData && Array.isArray(loadedData.chunks)) {
                                renderBoard(loadedData.chunks);
                                if (loadedData.viewport) {
                                    scale = loadedData.viewport.scale || 1;
                                    translateX = loadedData.viewport.translateX || 0;
                                    translateY = loadedData.viewport.translateY || 0;
                                    applyTransform();
                                } else {
                                    resetAndCenterView();
                                }
                                showMessage('Loaded from File', `Successfully loaded notes from ${file.name}.`);
                            } else {
                                throw new Error("Invalid file format. Expected 'chunks' array.");
                            }
                        }
                    } catch (error) {
                        showMessage('Load Error', `Could not load or parse file: ${error.message}.`);
                        console.error("Load error:", error);
                    } finally {
                        if(buttonToLoad) setButtonLoading(buttonToLoad, false);
                    }
                };
                reader.onerror = () => {
                    showMessage('Load Error', `Error reading file: ${reader.error}`);
                    if(buttonToLoad) setButtonLoading(buttonToLoad, false);
                    console.error("File read error:", reader.error);
                };
                reader.readAsText(file);
            };

            fileLoadInput.addEventListener('change', (event) => {
                fileLoadHandler(event.target.files[0], loadBtn, false);
                event.target.value = null;
            });
            customTemplateLoadInput.addEventListener('change', (event) => {
                const proceedLoad = () => {
                    fileLoadHandler(event.target.files[0], loadCustomTemplateBtn, true);
                    event.target.value = null;
                };

                if (chunks.length > 0) {
                     showMessage("Confirm Load Template", "Loading a template will clear the current board. Are you sure?", [
                        { text: 'Cancel', class: 'btn-secondary', action: () => { event.target.value = null; } },
                        { text: 'Load', class: 'btn-primary', action: proceedLoad }
                    ]);
                } else {
                    proceedLoad();
                }
            });
            
            // Canvas and keyboard listeners
            noteCanvasContainer.addEventListener('mousedown', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (linkingMode) { deselectAllChunks(); return; } currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('mousemove', onInteractionMove); document.addEventListener('mouseup', onInteractionEnd); } else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); } });
            noteCanvasContainer.addEventListener('touchstart', (e) => { if (e.target === noteCanvasContainer || e.target === transformContainer || e.target === noteCanvas) { if (e.touches.length === 1) { if (linkingMode) { deselectAllChunks(); e.preventDefault(); return; } e.preventDefault(); currentAction = 'pan'; const pointer = getPointerCoordinates(e); panStartX = pointer.x - translateX; panStartY = pointer.y - translateY; noteCanvasContainer.classList.add('panning'); document.addEventListener('touchmove', onInteractionMove, { passive: false }); document.addEventListener('touchend', onInteractionEnd); } else if (e.touches.length === 2) { e.preventDefault(); currentAction = 'pinch-zoom'; noteCanvasContainer.classList.remove('panning'); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; initialPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); } }  else if (!e.target.closest('.chorus-chunk') && !e.target.closest('.toolbar') && !e.target.closest('.modal')) { deselectAllChunks(); e.preventDefault(); } }, { passive: false });
            noteCanvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = noteCanvasContainer.getBoundingClientRect(); const mouseX = e.clientX - (rect.left || 0); const mouseY = e.clientY - (rect.top || 0); const worldXBeforeZoom = (mouseX - translateX) / scale; const worldYBeforeZoom = (mouseY - translateY) / scale; const delta = e.deltaY * ZOOM_SENSITIVITY * -1; let newScale = scale * (1 + delta); newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = mouseX - worldXBeforeZoom * newScale; translateY = mouseY - worldYBeforeZoom * newScale; scale = newScale; applyTransform(); }, { passive: false });
            noteCanvasContainer.addEventListener('touchmove', (e) => { if (currentAction === 'pinch-zoom' && e.touches.length === 2) { e.preventDefault(); const t1 = { x: e.touches[0].clientX, y: e.touches[0].clientY }; const t2 = { x: e.touches[1].clientX, y: e.touches[1].clientY }; const currentPinchDistance = Math.hypot(t1.x - t2.x, t1.y - t2.y); const pinchMidpointScreen = { x: (t1.x + t2.x) / 2, y: (t1.y + t2.y) / 2 }; if (initialPinchDistance === null) { initialPinchDistance = currentPinchDistance; return; } const rect = noteCanvasContainer.getBoundingClientRect(); const worldMidXBeforeZoom = (pinchMidpointScreen.x - (rect.left || 0) - translateX) / scale; const worldMidYBeforeZoom = (pinchMidpointScreen.y - (rect.top || 0) - translateY) / scale; let scaleChange = currentPinchDistance / initialPinchDistance; let newScale = scale * scaleChange; newScale = Math.max(MIN_SCALE, Math.min(newScale, MAX_SCALE)); translateX = (pinchMidpointScreen.x - (rect.left || 0)) - worldMidXBeforeZoom * newScale; translateY = (pinchMidpointScreen.y - (rect.top || 0)) - worldMidYBeforeZoom * newScale; scale = newScale; applyTransform(); initialPinchDistance = currentPinchDistance; } }, { passive: false });
            noteCanvasContainer.addEventListener('touchend', (e) => { if (e.touches.length < 2 && currentAction === 'pinch-zoom') { initialPinchDistance = null; currentAction = null; } });
            document.addEventListener('keydown', (e) => { 
                const activeEl = document.activeElement; 
                const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable); 
                const isCtrlOrCmd = e.ctrlKey || e.metaKey; 
                let shortcutHandled = false; 
                if (isCtrlOrCmd) { 
                    switch (e.key.toLowerCase()) { 
                        case 's': saveBtn.click(); shortcutHandled = true; break; 
                        case 'o': loadBtn.click(); shortcutHandled = true; break; 
                        case 'z': if (!undoDeleteBtn.disabled) { undoDeleteBtn.click(); shortcutHandled = true; } break; 
                    } 
                } 
                if(shortcutHandled){ e.preventDefault(); return; } 
                if (isInputFocused) { if (e.key === 'Escape') { activeEl.blur(); } return; } 
                switch(e.key.toLowerCase()){ 
                    case 'escape': 
                        if (!addChunkModal.classList.contains('hidden')) { hideModal(addChunkModal); } 
                        else if (!editChunkModal.classList.contains('hidden')) { hideModal(editChunkModal); } 
                        else if (!helpModal.classList.contains('hidden')) { hideModal(helpModal); } 
                        else if (!messageModal.classList.contains('hidden')) { hideModal(messageModal); } 
                        else if (!aiActionModal.classList.contains('hidden')) { hideModal(aiActionModal); } 
                        else if (!settingsModal.classList.contains('hidden')) { hideModal(settingsModal); } 
                        else if (linkingMode) { cancelLinkingMode(false); } 
                        else if (selectedChunkId) { deselectAllChunks(); } 
                        shortcutHandled = true; 
                        break; 
                    case 'delete': 
                    case 'backspace': 
                        if (selectedChunkId) { 
                            showMessage("Confirm Delete", `Are you sure you want to delete the selected chunk (${chunksMap.get(selectedChunkId)?.chunkTypeTag || 'chunk'})?`, [ 
                                { text: 'Cancel', class: 'btn-secondary' }, 
                                { text: 'Delete', class: 'btn-danger', action: () => { deleteChunk(selectedChunkId); }} 
                            ]); 
                            shortcutHandled = true; 
                        } 
                        break; 
                    case 'a': addChunkBtn.click(); shortcutHandled = true; break; 
                    case '+': case '=': zoomInBtn.click(); shortcutHandled = true; break; 
                    case '-': zoomOutBtn.click(); shortcutHandled = true; break; 
                    case '0': zoomResetBtn.click(); shortcutHandled = true; break; 
                    case '?': case '/': helpBtn.click(); shortcutHandled = true; break; 
                } 
                if(shortcutHandled){ e.preventDefault(); } 
            });

            // Final setup
            let resizeQueued = false;
            const appContainer = document.getElementById('appContainer');

            function setAppHeight() {
                if (appContainer) {
                    // Use window.innerHeight to get the actual visible viewport height
                    appContainer.style.height = `${window.innerHeight}px`;
                }
            }

            window.addEventListener('resize', () => { 
                if (resizeQueued) return; 
                resizeQueued = true; 
                requestAnimationFrame(() => { 
                    setAppHeight();
                    applyTransform(); 
                    resizeQueued = false; 
                }); 
            });
            
            // Set the height initially on load
            setAppHeight();
            resetAndCenterView();
            window.addEventListener('beforeunload', (event) => { if (chunks.length > 0) { event.preventDefault(); event.returnValue = ''; return ''; } });
            setTimeout(() => { document.getElementById('noteCanvasContainer').focus(); }, 100);
            
            console.log("CHORUS AI: Strategist's Edition V5 Initialized");
        }
        initializeApp();
    });
    </script>
</body>
</html>
